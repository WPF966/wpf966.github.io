<!DOCTYPE html>
<html lang="en">
    <head>
        
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Title -->
<title>C++提高编程 - wpf博客</title>

<!-- Icon -->
<link rel="icon" href="/images/headPortrait/one.JPG">

<!-- Fonts -->
<link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" as="style" onload="this.onload=null, this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript>



<!-- Style -->

<link rel="stylesheet" href="/styles/main.css">

<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-pure@1.0.1/dist/main.css"> -->


<!--js-->
<script src="/scripts/darkTheme.js"></script>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

    <meta name="generator" content="Hexo 5.4.0"></head>
    <body>
        <div class="main gt-bg-theme-color-first">
            <div class="main-content">
                
<nav class="navbar navbar-expand-lg">
    
	<a class="navbar-brand" href="/">
    
        <img class="user-avatar" src="/images/headPortrait/one.JPG" alt="头像">
        <div class="site-name gt-c-content-color-first">
            wpf博客
        </div>
    
	</a>
    <button aria-label="Navbar Toggler" class="navbar-toggler" type="button" id="changeNavbar">
        <i class="gt-c-content-color-first" style="font-size: 18px;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" height="18px" fill="currentColor">
                <path d="M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z" />
            </svg>
        </i>
    </button>
	
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center; ">
            
                <div class="nav-item">
                    <a href="/" class="menu gt-a-link" target="_self">首页</a>
                </div>
            
                <div class="nav-item">
                    <a href="/categories/" class="menu gt-a-link" target="_self">分类</a>
                </div>
            
                <div class="nav-item">
                    <a href="/archives/" class="menu gt-a-link" target="_self">归档</a>
                </div>
            
                <div class="nav-item">
                    <a href="/tags/" class="menu gt-a-link" target="_self">标签</a>
                </div>
            
                <div class="nav-item">
                    <a href="/about/" class="menu gt-a-link" target="_self">关于</a>
                </div>
            
			
			<div class="nav-item" style="padding: 1.0625rem 1.25rem .6875rem 1.25rem;" id="dark-mode-toggle-button">
			    <a href="javascript:applyCustomDarkModeSettings(toggleCustomDarkMode())" class="menu">
				    					
				    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" height="16" width="16">
				        <path fill="currentColor" d="M256 56c110.549 0 200 89.468 200 200 0 110.549-89.468 200-200 200-110.549 0-200-89.468-200-200 0-110.549 89.468-200 200-200m0-48C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8zm0 96c-83.947 0-152 68.053-152 152s68.053 152 152 152V104z"></path>
				    </svg>
				</a>
			</div>
        </div>
    </div>
</nav>

<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function() {
        let element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else { 
            element.style.display = 'none';
        }
    }	
</script>
                
<div class="post-container">
    <div class="post-detail gt-bg-theme-color-second gt-c-content-color-first">
        <article class="gt-post-content">
            <h1 class="post-title">C++提高编程</h1>
            <div class="post-info">
                <time class="post-time gt-c-content-color-first">
                    · 2021-08-07 ·
				</time>
                
                    
                        <a href="/tags/c/" class="post-tag">
                            c++
						</a>
                    
                
            </div>
            <hr>
            <div class="post-content gt-c-content-color-first">
                <ul>
<li>本阶段主要针对C++==泛型编程==和==STL==技术做详细讲解，探讨C++更深层的使用</li>
</ul>
<h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p>
<p>例如生活中的模板</p>
<p>一寸照片模板：</p>
<img src="/images/c++program/1547105026929.png" class="">



<p>PPT模板：</p>
<img src="/images/c++program/1547103297864.png" class="">



<img src="/images/c++program/1547103359158.png" class="">





<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h3 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h3><ul>
<li>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</li>
</ul>
<ul>
<li>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong> </li>
</ul>
<h4 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h4><p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong> </p>
<pre><code class="C++">template&lt;typename T&gt;
函数声明或定义
</code></pre>
<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<pre><code class="C++">
//交换整型函数
void swapInt(int&amp; a, int&amp; b) &#123;
    int temp = a;
    a = b;
    b = temp;
&#125;

//交换浮点型函数
void swapDouble(double&amp; a, double&amp; b) &#123;
    double temp = a;
    a = b;
    b = temp;
&#125;

//利用模板提供通用的交换函数
template&lt;typename T&gt;
void mySwap(T&amp; a, T&amp; b)
&#123;
    T temp = a;
    a = b;
    b = temp;
&#125;

void test01()
&#123;
    int a = 10;
    int b = 20;
    
    //swapInt(a, b);

    //利用模板实现交换
    //1、自动类型推导
    mySwap(a, b);

    //2、显示指定类型
    mySwap&lt;int&gt;(a, b);

    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;

&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h4 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h4><p>注意事项：</p>
<ul>
<li>自动类型推导，必须推导出一致的数据类型T,才可以使用</li>
</ul>
<ul>
<li>模板必须要确定出T的数据类型，才可以使用</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">//利用模板提供通用的交换函数
template&lt;class T&gt;
void mySwap(T&amp; a, T&amp; b)
&#123;
    T temp = a;
    a = b;
    b = temp;
&#125;


// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用
void test01()
&#123;
    int a = 10;
    int b = 20;
    char c = &#39;c&#39;;

    mySwap(a, b); // 正确，可以推导出一致的T
    //mySwap(a, c); // 错误，推导不出一致的T类型
&#125;


// 2、模板必须要确定出T的数据类型，才可以使用
template&lt;class T&gt;
void func()
&#123;
    cout &lt;&lt; &quot;func 调用&quot; &lt;&lt; endl;
&#125;

void test02()
&#123;
    //func(); //错误，模板不能独立使用，必须确定出T的类型
    func&lt;int&gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板
&#125;

int main() &#123;

    test01();
    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h4 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h4><p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<p>示例：</p>
<pre><code class="C++">//交换的函数模板
template&lt;typename T&gt;
void mySwap(T &amp;a, T&amp;b)
&#123;
    T temp = a;
    a = b;
    b = temp;
&#125;


template&lt;class T&gt; // 也可以替换成typename
//利用选择排序，进行对数组从大到小的排序
void mySort(T arr[], int len)
&#123;
    for (int i = 0; i &lt; len; i++)
    &#123;
        int max = i; //最大数的下标
        for (int j = i + 1; j &lt; len; j++)
        &#123;
            if (arr[max] &lt; arr[j])
            &#123;
                max = j;
            &#125;
        &#125;
        if (max != i) //如果最大数的下标不是i，交换两者
        &#123;
            mySwap(arr[max], arr[i]);
        &#125;
    &#125;
&#125;
template&lt;typename T&gt;
void printArray(T arr[], int len) &#123;

    for (int i = 0; i &lt; len; i++) &#123;
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;
void test01()
&#123;
    //测试char数组
    char charArr[] = &quot;bdcfeagh&quot;;
    int num = sizeof(charArr) / sizeof(char);
    mySort(charArr, num);
    printArray(charArr, num);
&#125;

void test02()
&#123;
    //测试int数组
    int intArr[] = &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;;
    int num = sizeof(intArr) / sizeof(int);
    mySort(intArr, num);
    printArray(intArr, num);
&#125;

int main() &#123;

    test01();
    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：模板可以提高代码复用，需要熟练掌握</p>
<h4 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">//普通函数
int myAdd01(int a, int b)
&#123;
    return a + b;
&#125;

//函数模板
template&lt;class T&gt;
T myAdd02(T a, T b)  
&#123;
    return a + b;
&#125;

//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换
void test01()
&#123;
    int a = 10;
    int b = 20;
    char c = &#39;c&#39;;
    
    cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的&#39;c&#39;隐式转换为int类型  &#39;c&#39; 对应 ASCII码 99

    //myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换

    myAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
<h4 id="1-2-5-普通函数与函数模板的调用规则"><a href="#1-2-5-普通函数与函数模板的调用规则" class="headerlink" title="1.2.5 普通函数与函数模板的调用规则"></a>1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<pre><code class="C++">//普通函数与函数模板调用规则
void myPrint(int a, int b)
&#123;
    cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;
&#125;

template&lt;typename T&gt;
void myPrint(T a, T b) 
&#123; 
    cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;
&#125;

template&lt;typename T&gt;
void myPrint(T a, T b, T c) 
&#123; 
    cout &lt;&lt; &quot;调用重载的模板&quot; &lt;&lt; endl; 
&#125;

void test01()
&#123;
    //1、如果函数模板和普通函数都可以实现，优先调用普通函数
    // 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到
    int a = 10;
    int b = 20;
    myPrint(a, b); //调用普通函数

    //2、可以通过空模板参数列表来强制调用函数模板
    myPrint&lt;&gt;(a, b); //调用函数模板

    //3、函数模板也可以发生重载
    int c = 30;
    myPrint(a, b, c); //调用重载的函数模板

    //4、 如果函数模板可以产生更好的匹配,优先调用函数模板
    char c1 = &#39;a&#39;;
    char c2 = &#39;b&#39;;
    myPrint(c1, c2); //调用函数模板
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<h4 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如：</strong></p>
<pre><code class="C++">    template&lt;class T&gt;
    void f(T a, T b)
    &#123; 
        a = b;
    &#125;
</code></pre>
<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<pre><code class="C++">    template&lt;class T&gt;
    void f(T a, T b)
    &#123; 
        if(a &gt; b) &#123; ... &#125;
    &#125;
</code></pre>
<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include&lt;iostream&gt;
using namespace std;

#include &lt;string&gt;

class Person
&#123;
public:
    Person(string name, int age)
    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;
    string m_Name;
    int m_Age;
&#125;;

//普通函数模板
template&lt;class T&gt;
bool myCompare(T&amp; a, T&amp; b)
&#123;
    if (a == b)
    &#123;
        return true;
    &#125;
    else
    &#123;
        return false;
    &#125;
&#125;


//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型
//具体化优先于常规模板
template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)
&#123;
    if ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)
    &#123;
        return true;
    &#125;
    else
    &#123;
        return false;
    &#125;
&#125;

void test01()
&#123;
    int a = 10;
    int b = 20;
    //内置数据类型可以直接使用通用的函数模板
    bool ret = myCompare(a, b);
    if (ret)
    &#123;
        cout &lt;&lt; &quot;a == b &quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl;
    &#125;
&#125;

void test02()
&#123;
    Person p1(&quot;Tom&quot;, 10);
    Person p2(&quot;Tom&quot;, 10);
    //自定义数据类型，不会调用普通的函数模板
    //可以创建具体化的Person数据类型的模板，用于特殊处理这个类型
    bool ret = myCompare(p1, p2);
    if (ret)
    &#123;
        cout &lt;&lt; &quot;p1 == p2 &quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;p1 != p2 &quot; &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;

    test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><h4 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h4><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li>
</ul>
<p><strong>语法：</strong> </p>
<pre><code class="c++">template&lt;typename T&gt;
类
</code></pre>
<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;string&gt;
//类模板
template&lt;class NameType, class AgeType&gt; 
class Person
&#123;
public:
    Person(NameType name, AgeType age)
    &#123;
        this-&gt;mName = name;
        this-&gt;mAge = age;
    &#125;
    void showPerson()
    &#123;
        cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;
    &#125;
public:
    NameType mName;
    AgeType mAge;
&#125;;

void test01()
&#123;
    // 指定NameType 为string类型，AgeType 为 int类型
    Person&lt;string, int&gt;P1(&quot;孙悟空&quot;, 999);
    P1.showPerson();
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h4 id="1-3-2-类模板与函数模板区别"><a href="#1-3-2-类模板与函数模板区别" class="headerlink" title="1.3.2 类模板与函数模板区别"></a>1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;string&gt;
//类模板
template&lt;class NameType, class AgeType = int&gt; 
class Person
&#123;
public:
    Person(NameType name, AgeType age)
    &#123;
        this-&gt;mName = name;
        this-&gt;mAge = age;
    &#125;
    void showPerson()
    &#123;
        cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;
    &#125;
public:
    NameType mName;
    AgeType mAge;
&#125;;

//1、类模板没有自动类型推导的使用方式
void test01()
&#123;
    // Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导
    Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板
    p.showPerson();
&#125;

//2、类模板在模板参数列表中可以有默认参数
void test02()
&#123;
    Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数
    p.showPerson();
&#125;

int main() &#123;

    test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h4 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">class Person1
&#123;
public:
    void showPerson1()
    &#123;
        cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl;
    &#125;
&#125;;

class Person2
&#123;
public:
    void showPerson2()
    &#123;
        cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl;
    &#125;
&#125;;

template&lt;class T&gt;
class MyClass
&#123;
public:
    T obj;

    //类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成

    void fun1() &#123; obj.showPerson1(); &#125;
    void fun2() &#123; obj.showPerson2(); &#125;

&#125;;

void test01()
&#123;
    MyClass&lt;Person1&gt; m;
    
    m.fun1();

    //m.fun2();//编译会出错，说明函数调用才会去创建成员函数
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h4 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h4><p>学习目标：</p>
<ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型   — 直接显示对象的数据类型</li>
<li>参数模板化           — 将对象中的参数变为模板进行传递</li>
<li>整个类模板化       — 将这个对象类型 模板化进行传递</li>
</ol>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;string&gt;
//类模板
template&lt;class NameType, class AgeType = int&gt; 
class Person
&#123;
public:
    Person(NameType name, AgeType age)
    &#123;
        this-&gt;mName = name;
        this-&gt;mAge = age;
    &#125;
    void showPerson()
    &#123;
        cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;
    &#125;
public:
    NameType mName;
    AgeType mAge;
&#125;;

//1、指定传入的类型
void printPerson1(Person&lt;string, int&gt; &amp;p) 
&#123;
    p.showPerson();
&#125;
void test01()
&#123;
    Person &lt;string, int &gt;p(&quot;孙悟空&quot;, 100);
    printPerson1(p);
&#125;

//2、参数模板化
template &lt;class T1, class T2&gt;
void printPerson2(Person&lt;T1, T2&gt;&amp;p)
&#123;
    p.showPerson();
    cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl;
    cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;
&#125;
void test02()
&#123;
    Person &lt;string, int &gt;p(&quot;猪八戒&quot;, 90);
    printPerson2(p);
&#125;

//3、整个类模板化
template&lt;class T&gt;
void printPerson3(T &amp; p)
&#123;
    cout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl;
    p.showPerson();

&#125;
void test03()
&#123;
    Person &lt;string, int &gt;p(&quot;唐僧&quot;, 30);
    printPerson3(p);
&#125;

int main() &#123;

    test01();
    test02();
    test03();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型</li>
</ul>
<h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">template&lt;class T&gt;
class Base
&#123;
    T m;
&#125;;

//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承
class Son :public Base&lt;int&gt; //必须指定一个类型
&#123;
&#125;;
void test01()
&#123;
    Son c;
&#125;

//类模板继承类模板 ,可以用T2指定父类中的T类型
template&lt;class T1, class T2&gt;
class Son2 :public Base&lt;T2&gt;
&#123;
public:
    Son2()
    &#123;
        cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;
        cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;
    &#125;
&#125;;

void test02()
&#123;
    Son2&lt;int, char&gt; child1;
&#125;


int main() &#123;

    test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h4 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;string&gt;

//类模板中成员函数类外实现
template&lt;class T1, class T2&gt;
class Person &#123;
public:
    //成员函数类内声明
    Person(T1 name, T2 age);
    void showPerson();

public:
    T1 m_Name;
    T2 m_Age;
&#125;;

//构造函数 类外实现
template&lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;
    this-&gt;m_Name = name;
    this-&gt;m_Age = age;
&#125;

//成员函数 类外实现
template&lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::showPerson() &#123;
    cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
&#125;

void test01()
&#123;
    Person&lt;string, int&gt; p(&quot;Tom&quot;, 20);
    p.showPerson();
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p>学习目标：</p>
<ul>
<li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li>
</ul>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含.cpp源文件</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p><strong>示例：</strong></p>
<p>person.hpp中代码：</p>
<pre><code class="C++">#pragma once
#include &lt;iostream&gt;
using namespace std;
#include &lt;string&gt;

template&lt;class T1, class T2&gt;
class Person &#123;
public:
    Person(T1 name, T2 age);
    void showPerson();
public:
    T1 m_Name;
    T2 m_Age;
&#125;;

//构造函数 类外实现
template&lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;
    this-&gt;m_Name = name;
    this-&gt;m_Age = age;
&#125;

//成员函数 类外实现
template&lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::showPerson() &#123;
    cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
&#125;
</code></pre>
<p>类模板分文件编写.cpp中代码</p>
<pre><code class="C++">#include&lt;iostream&gt;
using namespace std;

//#include &quot;person.h&quot;
#include &quot;person.cpp&quot; //解决方式1，包含cpp源文件

//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp
#include &quot;person.hpp&quot;
void test01()
&#123;
    Person&lt;string, int&gt; p(&quot;Tom&quot;, 10);
    p.showPerson();
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
</ul>
<p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;string&gt;

//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元
template&lt;class T1, class T2&gt; class Person;

//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到
//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); 

template&lt;class T1, class T2&gt;
void printPerson2(Person&lt;T1, T2&gt; &amp; p)
&#123;
    cout &lt;&lt; &quot;类外实现 ---- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;
&#125;

template&lt;class T1, class T2&gt;
class Person
&#123;
    //1、全局函数配合友元   类内实现
    friend void printPerson(Person&lt;T1, T2&gt; &amp; p)
    &#123;
        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p.m_Age &lt;&lt; endl;
    &#125;


    //全局函数配合友元  类外实现
    friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);

public:

    Person(T1 name, T2 age)
    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;


private:
    T1 m_Name;
    T2 m_Age;

&#125;;

//1、全局函数在类内实现
void test01()
&#123;
    Person &lt;string, int &gt;p(&quot;Tom&quot;, 20);
    printPerson(p);
&#125;


//2、全局函数在类外实现
void test02()
&#123;
    Person &lt;string, int &gt;p(&quot;Jerry&quot;, 30);
    printPerson2(p);
&#125;

int main() &#123;

    //test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p>
<h4 id="1-3-9-类模板案例"><a href="#1-3-9-类模板案例" class="headerlink" title="1.3.9 类模板案例"></a>1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p>
<ul>
<li>可以对内置数据类型以及自定义数据类型的数据进行存储</li>
<li>将数组中的数据存储到堆区</li>
<li>构造函数中可以传入数组的容量</li>
<li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li>
<li>提供尾插法和尾删法对数组中的数据进行增加和删除</li>
<li>可以通过下标的方式访问数组中的元素</li>
<li>可以获取数组中当前元素个数和数组的容量</li>
</ul>
<p><strong>示例：</strong></p>
<p>myArray.hpp中代码</p>
<pre><code class="C++">#pragma once
#include &lt;iostream&gt;
using namespace std;

template&lt;class T&gt;
class MyArray
&#123;
public:
    
    //构造函数
    MyArray(int capacity)
    &#123;
        this-&gt;m_Capacity = capacity;
        this-&gt;m_Size = 0;
        pAddress = new T[this-&gt;m_Capacity];
    &#125;

    //拷贝构造
    MyArray(const MyArray &amp; arr)
    &#123;
        this-&gt;m_Capacity = arr.m_Capacity;
        this-&gt;m_Size = arr.m_Size;
        this-&gt;pAddress = new T[this-&gt;m_Capacity];
        for (int i = 0; i &lt; this-&gt;m_Size; i++)
        &#123;
            //如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，
            // 普通类型可以直接= 但是指针类型需要深拷贝
            this-&gt;pAddress[i] = arr.pAddress[i];
        &#125;
    &#125;

    //重载= 操作符  防止浅拷贝问题
    MyArray&amp; operator=(const MyArray&amp; myarray) &#123;

        if (this-&gt;pAddress != NULL) &#123;
            delete[] this-&gt;pAddress;
            this-&gt;m_Capacity = 0;
            this-&gt;m_Size = 0;
        &#125;

        this-&gt;m_Capacity = myarray.m_Capacity;
        this-&gt;m_Size = myarray.m_Size;
        this-&gt;pAddress = new T[this-&gt;m_Capacity];
        for (int i = 0; i &lt; this-&gt;m_Size; i++) &#123;
            this-&gt;pAddress[i] = myarray[i];
        &#125;
        return *this;
    &#125;

    //重载[] 操作符  arr[0]
    T&amp; operator [](int index)
    &#123;
        return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理
    &#125;

    //尾插法
    void Push_back(const T &amp; val)
    &#123;
        if (this-&gt;m_Capacity == this-&gt;m_Size)
        &#123;
            return;
        &#125;
        this-&gt;pAddress[this-&gt;m_Size] = val;
        this-&gt;m_Size++;
    &#125;

    //尾删法
    void Pop_back()
    &#123;
        if (this-&gt;m_Size == 0)
        &#123;
            return;
        &#125;
        this-&gt;m_Size--;
    &#125;

    //获取数组容量
    int getCapacity()
    &#123;
        return this-&gt;m_Capacity;
    &#125;

    //获取数组大小
    int    getSize()
    &#123;
        return this-&gt;m_Size;
    &#125;


    //析构
    ~MyArray()
    &#123;
        if (this-&gt;pAddress != NULL)
        &#123;
            delete[] this-&gt;pAddress;
            this-&gt;pAddress = NULL;
            this-&gt;m_Capacity = 0;
            this-&gt;m_Size = 0;
        &#125;
    &#125;

private:
    T * pAddress;  //指向一个堆空间，这个空间存储真正的数据
    int m_Capacity; //容量
    int m_Size;   // 大小
&#125;;
</code></pre>
<p>类模板案例—数组类封装.cpp中</p>
<pre><code class="C++">#include &quot;myArray.hpp&quot;
#include &lt;string&gt;

void printIntArray(MyArray&lt;int&gt;&amp; arr) &#123;
    for (int i = 0; i &lt; arr.getSize(); i++) &#123;
        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

//测试内置数据类型
void test01()
&#123;
    MyArray&lt;int&gt; array1(10);
    for (int i = 0; i &lt; 10; i++)
    &#123;
        array1.Push_back(i);
    &#125;
    cout &lt;&lt; &quot;array1打印输出：&quot; &lt;&lt; endl;
    printIntArray(array1);
    cout &lt;&lt; &quot;array1的大小：&quot; &lt;&lt; array1.getSize() &lt;&lt; endl;
    cout &lt;&lt; &quot;array1的容量：&quot; &lt;&lt; array1.getCapacity() &lt;&lt; endl;

    cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl;

    MyArray&lt;int&gt; array2(array1);
    array2.Pop_back();
    cout &lt;&lt; &quot;array2打印输出：&quot; &lt;&lt; endl;
    printIntArray(array2);
    cout &lt;&lt; &quot;array2的大小：&quot; &lt;&lt; array2.getSize() &lt;&lt; endl;
    cout &lt;&lt; &quot;array2的容量：&quot; &lt;&lt; array2.getCapacity() &lt;&lt; endl;
&#125;

//测试自定义数据类型
class Person &#123;
public:
    Person() &#123;&#125; 
        Person(string name, int age) &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;
public:
    string m_Name;
    int m_Age;
&#125;;

void printPersonArray(MyArray&lt;Person&gt;&amp; personArr)
&#123;
    for (int i = 0; i &lt; personArr.getSize(); i++) &#123;
        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; personArr[i].m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; personArr[i].m_Age &lt;&lt; endl;
    &#125;

&#125;

void test02()
&#123;
    //创建数组
    MyArray&lt;Person&gt; pArray(10);
    Person p1(&quot;孙悟空&quot;, 30);
    Person p2(&quot;韩信&quot;, 20);
    Person p3(&quot;妲己&quot;, 18);
    Person p4(&quot;王昭君&quot;, 15);
    Person p5(&quot;赵云&quot;, 24);

    //插入数据
    pArray.Push_back(p1);
    pArray.Push_back(p2);
    pArray.Push_back(p3);
    pArray.Push_back(p4);
    pArray.Push_back(p5);

    printPersonArray(pArray);

    cout &lt;&lt; &quot;pArray的大小：&quot; &lt;&lt; pArray.getSize() &lt;&lt; endl;
    cout &lt;&lt; &quot;pArray的容量：&quot; &lt;&lt; pArray.getCapacity() &lt;&lt; endl;

&#125;

int main() &#123;

    //test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<p>能够利用所学知识点实现通用的数组</p>
<h2 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul>
<li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p>
</li>
<li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p>
</li>
<li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p>
</li>
<li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p>
</li>
</ul>
<h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul>
<li>STL(Standard Template Library,<strong>标准模板库</strong>)</li>
<li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p>​    <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​    <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<p><strong>算法：</strong>问题之解法也</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p><strong>迭代器：</strong>容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>
<h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>
<p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>
<h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p>
<p>算法：     <code>for_each</code></p>
<p>迭代器： <code>vector&lt;int&gt;::iterator</code></p>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

void MyPrint(int val)
&#123;
    cout &lt;&lt; val &lt;&lt; endl;
&#125;

void test01() &#123;

    //创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型
    vector&lt;int&gt; v;
    //向容器中放数据
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);

    //每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素
    //v.begin()返回迭代器，这个迭代器指向容器中第一个数据
    //v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置
    //vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型

    vector&lt;int&gt;::iterator pBegin = v.begin();
    vector&lt;int&gt;::iterator pEnd = v.end();

    //第一种遍历方式：
    while (pBegin != pEnd) &#123;
        cout &lt;&lt; *pBegin &lt;&lt; endl;
        pBegin++;
    &#125;

    
    //第二种遍历方式：
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; endl;
    &#125;
    cout &lt;&lt; endl;

    //第三种遍历方式：
    //使用STL提供标准遍历算法  头文件 algorithm
    for_each(v.begin(), v.end(), MyPrint);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p>
<p><strong>示例：</strong></p>
<pre><code class="c++">#include &lt;vector&gt;
#include &lt;string&gt;

//自定义数据类型
class Person &#123;
public:
    Person(string name, int age) &#123;
        mName = name;
        mAge = age;
    &#125;
public:
    string mName;
    int mAge;
&#125;;
//存放对象
void test01() &#123;

    vector&lt;Person&gt; v;

    //创建数据
    Person p1(&quot;aaa&quot;, 10);
    Person p2(&quot;bbb&quot;, 20);
    Person p3(&quot;ccc&quot;, 30);
    Person p4(&quot;ddd&quot;, 40);
    Person p5(&quot;eee&quot;, 50);

    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);
    v.push_back(p5);

    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl;

    &#125;
&#125;


//放对象指针
void test02() &#123;

    vector&lt;Person*&gt; v;

    //创建数据
    Person p1(&quot;aaa&quot;, 10);
    Person p2(&quot;bbb&quot;, 20);
    Person p3(&quot;ccc&quot;, 30);
    Person p4(&quot;ddd&quot;, 40);
    Person p5(&quot;eee&quot;, 50);

    v.push_back(&amp;p1);
    v.push_back(&amp;p2);
    v.push_back(&amp;p3);
    v.push_back(&amp;p4);
    v.push_back(&amp;p5);

    for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        Person * p = (*it);
        cout &lt;&lt; &quot;Name:&quot; &lt;&lt; p-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;
    &#125;
&#125;


int main() &#123;

    test01();
    
    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h4 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;

//容器嵌套容器
void test01() &#123;

    vector&lt; vector&lt;int&gt; &gt;  v;

    vector&lt;int&gt; v1;
    vector&lt;int&gt; v2;
    vector&lt;int&gt; v3;
    vector&lt;int&gt; v4;

    for (int i = 0; i &lt; 4; i++) &#123;
        v1.push_back(i + 1);
        v2.push_back(i + 2);
        v3.push_back(i + 3);
        v4.push_back(i + 4);
    &#125;

    //将容器元素插入到vector v中
    v.push_back(v1);
    v.push_back(v2);
    v.push_back(v3);
    v.push_back(v4);


    for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;

        for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123;
            cout &lt;&lt; *vit &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
    &#125;

&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<h2 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL- 常用容器"></a>3 STL- 常用容器</h2><h3 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h3><h4 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h4><p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类</li>
</ul>
<p><strong>string和char * 区别：</strong></p>
<ul>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li>
</ul>
<p><strong>特点：</strong></p>
<p>string 类内部封装了很多成员方法</p>
<p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h4 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h4><p>构造函数原型：</p>
<ul>
<li><code>string();</code>                          //创建一个空的字符串 例如: string str;<br>   <code>string(const char* s);</code>            //使用字符串s初始化</li>
<li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象</li>
<li><code>string(int n, char c);</code>           //使用n个字符c初始化 </li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;string&gt;
//string构造
void test01()
&#123;
    string s1; //创建空字符串，调用无参构造函数
    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; s1 &lt;&lt; endl;

    const char* str = &quot;hello world&quot;;
    string s2(str); //把c_string转换成了string

    cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; s2 &lt;&lt; endl;

    string s3(s2); //调用拷贝构造函数
    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;

    string s4(10, &#39;a&#39;);
    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：string的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h4><p>功能描述：</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型：</p>
<ul>
<li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li>
<li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li>
<li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">//赋值
void test01()
&#123;
    string str1;
    str1 = &quot;hello world&quot;;
    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;

    string str2;
    str2 = str1;
    cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; endl;

    string str3;
    str3 = &#39;a&#39;;
    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;

    string str4;
    str4.assign(&quot;hello c++&quot;);
    cout &lt;&lt; &quot;str4 = &quot; &lt;&lt; str4 &lt;&lt; endl;

    string str5;
    str5.assign(&quot;hello c++&quot;,5);
    cout &lt;&lt; &quot;str5 = &quot; &lt;&lt; str5 &lt;&lt; endl;


    string str6;
    str6.assign(str5);
    cout &lt;&lt; &quot;str6 = &quot; &lt;&lt; str6 &lt;&lt; endl;

    string str7;
    str7.assign(5, &#39;x&#39;);
    cout &lt;&lt; &quot;str7 = &quot; &lt;&lt; str7 &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<p>​    string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p>
<h4 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; operator+=(const char* str);</code>                   //重载+=操作符</li>
<li><code>string&amp; operator+=(const char c);</code>                         //重载+=操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code>                //重载+=操作符</li>
<li><code>string&amp; append(const char *s); </code>                               //把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">//字符串拼接
void test01()
&#123;
    string str1 = &quot;我&quot;;

    str1 += &quot;爱玩游戏&quot;;

    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;
    
    str1 += &#39;:&#39;;

    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;

    string str2 = &quot;LOL DNF&quot;;

    str1 += str2;

    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;

    string str3 = &quot;I&quot;;
    str3.append(&quot; love &quot;);
    str3.append(&quot;game abcde&quot;, 4);
    //str3.append(str2);
    str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾
    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;
&#125;
int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p>
<h4 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0) const; </code>                     //查找s第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos, int n) const; </code>               //从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const; </code>                       //查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;  </code>                      //查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       //替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s); </code>                 //替换从pos开始的n个字符为字符串s</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">//查找和替换
void test01()
&#123;
    //查找
    string str1 = &quot;abcdefgde&quot;;

    int pos = str1.find(&quot;de&quot;);

    if (pos == -1)
    &#123;
        cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;
    &#125;
    

    pos = str1.rfind(&quot;de&quot;);

    cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;

&#125;

void test02()
&#123;
    //替换
    string str1 = &quot;abcdefgde&quot;;
    str1.replace(1, 3, &quot;1111&quot;);

    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;
&#125;

int main() &#123;

    //test01();
    //test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h4 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p><strong>比较方式：</strong></p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
</ul>
<p>= 返回   0</p>
<p>&gt; 返回   1 </p>
<p>&lt; 返回  -1</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li>
<li><code>int compare(const char *s) const;</code>      //与字符串s比较</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">//字符串比较
void test01()
&#123;

    string s1 = &quot;hello&quot;;
    string s2 = &quot;aello&quot;;

    int ret = s1.compare(s2);

    if (ret == 0) &#123;
        cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;
    &#125;
    else if (ret &gt; 0)
    &#123;
        cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;
    &#125;

&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n); </code>     //通过[]方式取字符</li>
<li><code>char&amp; at(int n);   </code>                    //通过at方法获取字符</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">void test01()
&#123;
    string str = &quot;hello world&quot;;

    for (int i = 0; i &lt; str.size(); i++)
    &#123;
        cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;

    for (int i = 0; i &lt; str.size(); i++)
    &#123;
        cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;


    //字符修改
    str[0] = &#39;x&#39;;
    str.at(1) = &#39;x&#39;;
    cout &lt;&lt; str &lt;&lt; endl;
    
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>
<h4 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对string字符串进行插入和删除字符操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; insert(int pos, const char* s);  </code>                //插入字符串</li>
<li><code>string&amp; insert(int pos, const string&amp; str); </code>        //插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符 </li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">//字符串插入和删除
void test01()
&#123;
    string str = &quot;hello&quot;;
    str.insert(1, &quot;111&quot;);
    cout &lt;&lt; str &lt;&lt; endl;

    str.erase(1, 3);  //从1号位置开始3个字符
    cout &lt;&lt; str &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p>
<h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p><strong>功能描述：</strong></p>
<ul>
<li>从字符串中获取想要的子串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">//子串
void test01()
&#123;

    string str = &quot;abcdefg&quot;;
    string subStr = str.substr(1, 3);
    cout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl;

    string email = &quot;hello@sina.com&quot;;
    int pos = email.find(&quot;@&quot;);
    string username = email.substr(0, pos);
    cout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl;

&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>
<h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector与普通数组区别：</strong></p>
<ul>
<li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li>
</ul>
<p><strong>动态扩展：</strong></p>
<ul>
<li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
</ul>
<img src="/images/c++program/clip_image002.jpg" class="">



<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&lt;T&gt; v; </code>                            //采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) &#123;

    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

void test01()
&#123;
    vector&lt;int&gt; v1; //无参构造
    for (int i = 0; i &lt; 10; i++)
    &#123;
        v1.push_back(i);
    &#125;
    printVector(v1);

    vector&lt;int&gt; v2(v1.begin(), v1.end());
    printVector(v2);

    vector&lt;int&gt; v3(10, 100);
    printVector(v3);
    
    vector&lt;int&gt; v4(v3);
    printVector(v4);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p>
<h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li>
</ul>
<ul>
<li><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) &#123;

    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

//赋值操作
void test01()
&#123;
    vector&lt;int&gt; v1; //无参构造
    for (int i = 0; i &lt; 10; i++)
    &#123;
        v1.push_back(i);
    &#125;
    printVector(v1);

    vector&lt;int&gt;v2;
    v2 = v1;
    printVector(v2);

    vector&lt;int&gt;v3;
    v3.assign(v1.begin(), v1.end());
    printVector(v3);

    vector&lt;int&gt;v4;
    v4.assign(10, 100);
    printVector(v4);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p>
<h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器的容量和大小操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>empty(); </code>                            //判断容器是否为空</p>
</li>
<li><p><code>capacity();</code>                      //容器的容量</p>
</li>
<li><p><code>size();</code>                              //返回容器中元素的个数</p>
</li>
<li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​                          //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<p>​                              //如果容器变短，则末尾超出容器长度的元素被删除</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) &#123;

    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

void test01()
&#123;
    vector&lt;int&gt; v1;
    for (int i = 0; i &lt; 10; i++)
    &#123;
        v1.push_back(i);
    &#125;
    printVector(v1);
    if (v1.empty())
    &#123;
        cout &lt;&lt; &quot;v1为空&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;v1不为空&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;v1的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;
        cout &lt;&lt; &quot;v1的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl;
    &#125;

    //resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充
    v1.resize(15,10);
    printVector(v1);

    //resize 重新指定大小 ，若指定的更小，超出部分元素被删除
    v1.resize(5);
    printVector(v1);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>判断是否为空  — empty</li>
<li>返回元素个数  — size</li>
<li>返回容器容量  — capacity</li>
<li>重新指定大小  —  resize</li>
</ul>
<h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器进行插入、删除操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(ele);</code>                                         //尾部插入元素ele</li>
<li><code>pop_back();</code>                                                //删除最后一个元素</li>
<li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li>
<li><code>clear();</code>                                                        //删除容器中所有元素</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">
#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) &#123;

    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

//插入和删除
void test01()
&#123;
    vector&lt;int&gt; v1;
    //尾插
    v1.push_back(10);
    v1.push_back(20);
    v1.push_back(30);
    v1.push_back(40);
    v1.push_back(50);
    printVector(v1);
    //尾删
    v1.pop_back();
    printVector(v1);
    //插入
    v1.insert(v1.begin(), 100);
    printVector(v1);

    v1.insert(v1.begin(), 2, 1000);
    printVector(v1);

    //删除
    v1.erase(v1.begin());
    printVector(v1);

    //清空
    v1.erase(v1.begin(), v1.end());
    v1.clear();
    printVector(v1);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>尾插  — push_back</li>
<li>尾删  — pop_back</li>
<li>插入  — insert    (位置迭代器)</li>
<li>删除  — erase  （位置迭代器）</li>
<li>清空  —  clear  </li>
</ul>
<h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对vector中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     //返回索引idx所指的数据</li>
<li><code>operator[]; </code>       //返回索引idx所指的数据</li>
<li><code>front(); </code>            //返回容器中第一个数据元素</li>
<li><code>back();</code>              //返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;

void test01()
&#123;
    vector&lt;int&gt;v1;
    for (int i = 0; i &lt; 10; i++)
    &#123;
        v1.push_back(i);
    &#125;

    for (int i = 0; i &lt; v1.size(); i++)
    &#123;
        cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;

    for (int i = 0; i &lt; v1.size(); i++)
    &#123;
        cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;v1的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;
    cout &lt;&lt; &quot;v1的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现两个容器内元素进行互换</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(vec);</code>  // 将vec与本身的元素互换</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;

void printVector(vector&lt;int&gt;&amp; v) &#123;

    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

void test01()
&#123;
    vector&lt;int&gt;v1;
    for (int i = 0; i &lt; 10; i++)
    &#123;
        v1.push_back(i);
    &#125;
    printVector(v1);

    vector&lt;int&gt;v2;
    for (int i = 10; i &gt; 0; i--)
    &#123;
        v2.push_back(i);
    &#125;
    printVector(v2);

    //互换容器
    cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;
    v1.swap(v2);
    printVector(v1);
    printVector(v2);
&#125;

void test02()
&#123;
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 100000; i++) &#123;
        v.push_back(i);
    &#125;

    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;

    v.resize(3);

    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;

    //收缩内存
    vector&lt;int&gt;(v).swap(v); //匿名对象

    cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
    cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;

void test01()
&#123;
    vector&lt;int&gt; v;

    //预留空间
    v.reserve(100000);

    int num = 0;
    int* p = NULL;
    for (int i = 0; i &lt; 100000; i++) &#123;
        v.push_back(i);
        if (p != &amp;v[0]) &#123;
            p = &amp;v[0];
            num++;
        &#125;
    &#125;

    cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;
&#125;

int main() &#123;

    test01();
    
    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p><strong>deque与vector区别：</strong></p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度回比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li>
</ul>
<img src="/images/c++program/clip_image002-1547547642923.jpg" class="">



<p>deque内部工作原理:</p>
<p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<img src="/images/c++program/clip_image002-1547547896341.jpg" class="">

<ul>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>deque容器构造</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</li>
<li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li>
<li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
&#123;
    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;

    &#125;
    cout &lt;&lt; endl;
&#125;
//deque构造
void test01() &#123;

    deque&lt;int&gt; d1; //无参构造函数
    for (int i = 0; i &lt; 10; i++)
    &#123;
        d1.push_back(i);
    &#125;
    printDeque(d1);
    deque&lt;int&gt; d2(d1.begin(),d1.end());
    printDeque(d2);

    deque&lt;int&gt;d3(10,100);
    printDeque(d3);

    deque&lt;int&gt;d4 = d3;
    printDeque(d4);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给deque容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&amp; operator=(const deque &amp;deq); </code>         //重载等号操作符</li>
</ul>
<ul>
<li><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
&#123;
    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;

    &#125;
    cout &lt;&lt; endl;
&#125;
//赋值操作
void test01()
&#123;
    deque&lt;int&gt; d1;
    for (int i = 0; i &lt; 10; i++)
    &#123;
        d1.push_back(i);
    &#125;
    printDeque(d1);

    deque&lt;int&gt;d2;
    d2 = d1;
    printDeque(d2);

    deque&lt;int&gt;d3;
    d3.assign(d1.begin(), d1.end());
    printDeque(d3);

    deque&lt;int&gt;d4;
    d4.assign(10, 100);
    printDeque(d4);

&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：deque赋值操作也与vector相同，需熟练掌握</p>
<h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>deque.empty();</code>                       //判断容器是否为空</p>
</li>
<li><p><code>deque.size();</code>                         //返回容器中元素的个数</p>
</li>
<li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p>
<p>​                                         //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p>
<p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
&#123;
    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;

    &#125;
    cout &lt;&lt; endl;
&#125;

//大小操作
void test01()
&#123;
    deque&lt;int&gt; d1;
    for (int i = 0; i &lt; 10; i++)
    &#123;
        d1.push_back(i);
    &#125;
    printDeque(d1);

    //判断容器是否为空
    if (d1.empty()) &#123;
        cout &lt;&lt; &quot;d1为空!&quot; &lt;&lt; endl;
    &#125;
    else &#123;
        cout &lt;&lt; &quot;d1不为空!&quot; &lt;&lt; endl;
        //统计大小
        cout &lt;&lt; &quot;d1的大小为：&quot; &lt;&lt; d1.size() &lt;&lt; endl;
    &#125;

    //重新指定大小
    d1.resize(15, 1);
    printDeque(d1);

    d1.resize(5);
    printDeque(d1);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>deque没有容量的概念</li>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<p>两端插入操作：</p>
<ul>
<li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li>
<li><code>push_front(elem);</code>        //在容器头部插入一个数据</li>
<li><code>pop_back();</code>                   //删除容器最后一个数据</li>
<li><code>pop_front();</code>                 //删除容器第一个数据</li>
</ul>
<p>指定位置操作：</p>
<ul>
<li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
</li>
<li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p>
</li>
<li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p>
</li>
<li><p><code>clear();</code>                           //清空容器的所有数据</p>
</li>
<li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
</li>
<li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
&#123;
    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;

    &#125;
    cout &lt;&lt; endl;
&#125;
//两端操作
void test01()
&#123;
    deque&lt;int&gt; d;
    //尾插
    d.push_back(10);
    d.push_back(20);
    //头插
    d.push_front(100);
    d.push_front(200);

    printDeque(d);

    //尾删
    d.pop_back();
    //头删
    d.pop_front();
    printDeque(d);
&#125;

//插入
void test02()
&#123;
    deque&lt;int&gt; d;
    d.push_back(10);
    d.push_back(20);
    d.push_front(100);
    d.push_front(200);
    printDeque(d);

    d.insert(d.begin(), 1000);
    printDeque(d);

    d.insert(d.begin(), 2,10000);
    printDeque(d);

    deque&lt;int&gt;d2;
    d2.push_back(1);
    d2.push_back(2);
    d2.push_back(3);

    d.insert(d.begin(), d2.begin(), d2.end());
    printDeque(d);

&#125;

//删除
void test03()
&#123;
    deque&lt;int&gt; d;
    d.push_back(10);
    d.push_back(20);
    d.push_front(100);
    d.push_front(200);
    printDeque(d);

    d.erase(d.begin());
    printDeque(d);

    d.erase(d.begin(), d.end());
    d.clear();
    printDeque(d);
&#125;

int main() &#123;

    //test01();

    //test02();

    test03();
    
    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>插入和删除提供的位置是迭代器！</li>
<li>尾插   —  push_back</li>
<li>尾删   —  pop_back</li>
<li>头插   —  push_front</li>
<li>头删   —  pop_front</li>
</ul>
<h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对deque 中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     //返回索引idx所指的数据</li>
<li><code>operator[]; </code>      //返回索引idx所指的数据</li>
<li><code>front(); </code>            //返回容器中第一个数据元素</li>
<li><code>back();</code>              //返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;deque&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
&#123;
    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;

    &#125;
    cout &lt;&lt; endl;
&#125;

//数据存取
void test01()
&#123;

    deque&lt;int&gt; d;
    d.push_back(10);
    d.push_back(20);
    d.push_front(100);
    d.push_front(200);

    for (int i = 0; i &lt; d.size(); i++) &#123;
        cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;


    for (int i = 0; i &lt; d.size(); i++) &#123;
        cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;

    cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;

&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>利用算法实现对deque容器进行排序</li>
</ul>
<p><strong>算法：</strong></p>
<ul>
<li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;deque&gt;
#include &lt;algorithm&gt;

void printDeque(const deque&lt;int&gt;&amp; d) 
&#123;
    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;

    &#125;
    cout &lt;&lt; endl;
&#125;

void test01()
&#123;

    deque&lt;int&gt; d;
    d.push_back(10);
    d.push_back(20);
    d.push_front(100);
    d.push_front(200);

    printDeque(d);
    sort(d.begin(), d.end());
    printDeque(d);

&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>
<h3 id="3-4-案例-评委打分"><a href="#3-4-案例-评委打分" class="headerlink" title="3.4 案例-评委打分"></a>3.4 案例-评委打分</h3><h4 id="3-4-1-案例描述"><a href="#3-4-1-案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p>
<h4 id="3-4-2-实现步骤"><a href="#3-4-2-实现步骤" class="headerlink" title="3.4.2 实现步骤"></a>3.4.2 实现步骤</h4><ol>
<li>创建五名选手，放到vector中</li>
<li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li>
<li>sort算法对deque容器中分数排序，去除最高和最低分</li>
<li>deque容器遍历一遍，累加总分</li>
<li>获取平均分</li>
</ol>
<p><strong>示例代码：</strong></p>
<pre><code class="C++">//选手类
class Person
&#123;
public:
    Person(string name, int score)
    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Score = score;
    &#125;

    string m_Name; //姓名
    int m_Score;  //平均分
&#125;;

void createPerson(vector&lt;Person&gt;&amp;v)
&#123;
    string nameSeed = &quot;ABCDE&quot;;
    for (int i = 0; i &lt; 5; i++)
    &#123;
        string name = &quot;选手&quot;;
        name += nameSeed[i];

        int score = 0;

        Person p(name, score);

        //将创建的person对象 放入到容器中
        v.push_back(p);
    &#125;
&#125;

//打分
void setScore(vector&lt;Person&gt;&amp;v)
&#123;
    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)
    &#123;
        //将评委的分数 放入到deque容器中
        deque&lt;int&gt;d;
        for (int i = 0; i &lt; 10; i++)
        &#123;
            int score = rand() % 41 + 60;  // 60 ~ 100
            d.push_back(score);
        &#125;

        //cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;
        //for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)
        //&#123;
        //    cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;
        //&#125;
        //cout &lt;&lt; endl;

        //排序
        sort(d.begin(), d.end());

        //去除最高和最低分
        d.pop_back();
        d.pop_front();

        //取平均分
        int sum = 0;
        for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)
        &#123;
            sum += *dit; //累加每个评委的分数
        &#125;

        int avg = sum / d.size();

        //将平均分 赋值给选手身上
        it-&gt;m_Score = avg;
    &#125;

&#125;

void showScore(vector&lt;Person&gt;&amp;v)
&#123;
    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)
    &#123;
        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 平均分： &quot; &lt;&lt; it-&gt;m_Score &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;

    //随机数种子
    srand((unsigned int)time(NULL));

    //1、创建5名选手
    vector&lt;Person&gt;v;  //存放选手容器
    createPerson(v);

    //测试
    //for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)
    //&#123;
    //    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;
    //&#125;

    //2、给5名选手打分
    setScore(v);

    //3、显示最后得分
    showScore(v);

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p>
<h3 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念"><a href="#3-5-1-stack-基本概念" class="headerlink" title="3.5.1 stack 基本概念"></a>3.5.1 stack 基本概念</h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p>
<img src="/images/c++program/clip_image002-1547604555425.jpg" class="">

<p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p>
<p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p>
<p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p>
<p>生活中的栈：</p>
<img src="/images/c++program/clip_image002.png" class="">





<img src="/images/c++program/clip_image002-1547605111510.jpg" class="">



<h4 id="3-5-2-stack-常用接口"><a href="#3-5-2-stack-常用接口" class="headerlink" title="3.5.2 stack 常用接口"></a>3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>      //向栈顶添加元素</li>
<li><code>pop();</code>                //从栈顶移除第一个元素</li>
<li><code>top(); </code>                //返回栈顶元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            //判断堆栈是否为空</li>
<li><code>size(); </code>              //返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;stack&gt;

//栈容器常用接口
void test01()
&#123;
    //创建栈容器 栈容器必须符合先进后出
    stack&lt;int&gt; s;

    //向栈中添加元素，叫做 压栈 入栈
    s.push(10);
    s.push(20);
    s.push(30);

    while (!s.empty()) &#123;
        //输出栈顶元素
        cout &lt;&lt; &quot;栈顶元素为： &quot; &lt;&lt; s.top() &lt;&lt; endl;
        //弹出栈顶元素
        s.pop();
    &#125;
    cout &lt;&lt; &quot;栈的大小为：&quot; &lt;&lt; s.size() &lt;&lt; endl;

&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>入栈   — push</li>
<li>出栈   — pop</li>
<li>返回栈顶   — top</li>
<li>判断栈是否为空   — empty</li>
<li>返回栈大小   — size</li>
</ul>
<h3 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念"><a href="#3-6-1-queue-基本概念" class="headerlink" title="3.6.1 queue 基本概念"></a>3.6.1 queue 基本概念</h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p>
<img src="/images/c++program/clip_image002-1547606475892.jpg" class="">

<p>队列容器允许从一端新增元素，从另一端移除元素</p>
<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>
<p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p>
<p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p>
<p>生活中的队列：</p>
<img src="/images/c++program/1547606785041.png" class="">







<h4 id="3-6-2-queue-常用接口"><a href="#3-6-2-queue-常用接口" class="headerlink" title="3.6.2 queue 常用接口"></a>3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>                             //往队尾添加元素</li>
<li><code>pop();</code>                                      //从队头移除第一个元素</li>
<li><code>back();</code>                                    //返回最后一个元素</li>
<li><code>front(); </code>                                  //返回第一个元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            //判断堆栈是否为空</li>
<li><code>size(); </code>              //返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;queue&gt;
#include &lt;string&gt;
class Person
&#123;
public:
    Person(string name, int age)
    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;

    string m_Name;
    int m_Age;
&#125;;

void test01() &#123;

    //创建队列
    queue&lt;Person&gt; q;

    //准备数据
    Person p1(&quot;唐僧&quot;, 30);
    Person p2(&quot;孙悟空&quot;, 1000);
    Person p3(&quot;猪八戒&quot;, 900);
    Person p4(&quot;沙僧&quot;, 800);

    //向队列中添加元素  入队操作
    q.push(p1);
    q.push(p2);
    q.push(p3);
    q.push(p4);

    //队列不提供迭代器，更不支持随机访问    
    while (!q.empty()) &#123;
        //输出队头元素
        cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name 
              &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl;
        
        cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name  
              &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl;
        
        cout &lt;&lt; endl;
        //弹出队头元素
        q.pop();
    &#125;

    cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>入队   — push</li>
<li>出队   — pop</li>
<li>返回队头元素   — front</li>
<li>返回队尾元素   — back</li>
<li>判断队是否为空   — empty</li>
<li>返回队列大小   — size</li>
</ul>
<h3 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h3><h4 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h4><p><strong>功能：</strong>将数据进行链式存储</p>
<p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成：链表由一系列<strong>结点</strong>组成</p>
<p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p>
<p>STL中的链表是一个双向循环链表</p>
<img src="/images/c++program/clip_image002-1547608564071.jpg" class="">

<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p>
<p>list的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点：</p>
<ul>
<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>
</ul>
<p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p>
<p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p>
<h4 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>创建list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li>
<li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li>
<li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;list&gt;

void printList(const list&lt;int&gt;&amp; L) &#123;

    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

void test01()
&#123;
    list&lt;int&gt;L1;
    L1.push_back(10);
    L1.push_back(20);
    L1.push_back(30);
    L1.push_back(40);

    printList(L1);

    list&lt;int&gt;L2(L1.begin(),L1.end());
    printList(L2);

    list&lt;int&gt;L3(L2);
    printList(L3);

    list&lt;int&gt;L4(10, 1000);
    printList(L4);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h4 id="3-7-3-list-赋值和交换"><a href="#3-7-3-list-赋值和交换" class="headerlink" title="3.7.3 list 赋值和交换"></a>3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>给list容器进行赋值，以及交换list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li>
<li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li>
<li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;list&gt;

void printList(const list&lt;int&gt;&amp; L) &#123;

    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

//赋值和交换
void test01()
&#123;
    list&lt;int&gt;L1;
    L1.push_back(10);
    L1.push_back(20);
    L1.push_back(30);
    L1.push_back(40);
    printList(L1);

    //赋值
    list&lt;int&gt;L2;
    L2 = L1;
    printList(L2);

    list&lt;int&gt;L3;
    L3.assign(L2.begin(), L2.end());
    printList(L3);

    list&lt;int&gt;L4;
    L4.assign(10, 100);
    printList(L4);

&#125;

//交换
void test02()
&#123;

    list&lt;int&gt;L1;
    L1.push_back(10);
    L1.push_back(20);
    L1.push_back(30);
    L1.push_back(40);

    list&lt;int&gt;L2;
    L2.assign(10, 100);

    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;
    printList(L1);
    printList(L2);

    cout &lt;&lt; endl;

    L1.swap(L2);

    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;
    printList(L1);
    printList(L2);

&#125;

int main() &#123;

    //test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：list赋值和交换操作能够灵活运用即可</p>
<h4 id="3-7-4-list-大小操作"><a href="#3-7-4-list-大小操作" class="headerlink" title="3.7.4 list 大小操作"></a>3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>size(); </code>                             //返回容器中元素的个数</p>
</li>
<li><p><code>empty(); </code>                           //判断容器是否为空</p>
</li>
<li><p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
<p>​                        //如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>resize(num, elem); </code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p>
<pre><code>                                           //如果容器变短，则末尾超出容器长度的元素被删除。
</code></pre>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;list&gt;

void printList(const list&lt;int&gt;&amp; L) &#123;

    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

//大小操作
void test01()
&#123;
    list&lt;int&gt;L1;
    L1.push_back(10);
    L1.push_back(20);
    L1.push_back(30);
    L1.push_back(40);

    if (L1.empty())
    &#123;
        cout &lt;&lt; &quot;L1为空&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;L1不为空&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;L1的大小为： &quot; &lt;&lt; L1.size() &lt;&lt; endl;
    &#125;

    //重新指定大小
    L1.resize(10);
    printList(L1);

    L1.resize(2);
    printList(L1);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h4 id="3-7-5-list-插入和删除"><a href="#3-7-5-list-插入和删除" class="headerlink" title="3.7.5 list 插入和删除"></a>3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器进行数据的插入和删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li>push_back(elem);//在容器尾部加入一个元素</li>
<li>pop_back();//删除容器中最后一个元素</li>
<li>push_front(elem);//在容器开头插入一个元素</li>
<li>pop_front();//从容器开头移除第一个元素</li>
<li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();//移除容器的所有数据</li>
<li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);//删除容器中所有与elem值匹配的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;list&gt;

void printList(const list&lt;int&gt;&amp; L) &#123;

    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

//插入和删除
void test01()
&#123;
    list&lt;int&gt; L;
    //尾插
    L.push_back(10);
    L.push_back(20);
    L.push_back(30);
    //头插
    L.push_front(100);
    L.push_front(200);
    L.push_front(300);

    printList(L);

    //尾删
    L.pop_back();
    printList(L);

    //头删
    L.pop_front();
    printList(L);

    //插入
    list&lt;int&gt;::iterator it = L.begin();
    L.insert(++it, 1000);
    printList(L);

    //删除
    it = L.begin();
    L.erase(++it);
    printList(L);

    //移除
    L.push_back(10000);
    L.push_back(10000);
    L.push_back(10000);
    printList(L);
    L.remove(10000);
    printList(L);
    
    //清空
    L.clear();
    printList(L);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>尾插   — push_back</li>
<li>尾删   — pop_back</li>
<li>头插   — push_front</li>
<li>头删   — pop_front</li>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>移除   — remove</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-7-6-list-数据存取"><a href="#3-7-6-list-数据存取" class="headerlink" title="3.7.6 list 数据存取"></a>3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器中数据进行存取</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>front();</code>        //返回第一个元素。</li>
<li><code>back();</code>         //返回最后一个元素。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;list&gt;

//数据存取
void test01()
&#123;
    list&lt;int&gt;L1;
    L1.push_back(10);
    L1.push_back(20);
    L1.push_back(30);
    L1.push_back(40);

    
    //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据
    //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据
    cout &lt;&lt; &quot;第一个元素为： &quot; &lt;&lt; L1.front() &lt;&lt; endl;
    cout &lt;&lt; &quot;最后一个元素为： &quot; &lt;&lt; L1.back() &lt;&lt; endl;

    //list容器的迭代器是双向迭代器，不支持随机访问
    list&lt;int&gt;::iterator it = L1.begin();
    //it = it + 1;//错误，不可以跳跃访问，即使是+1
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素   — front</li>
<li>返回最后一个元素   — back</li>
</ul>
<h4 id="3-7-7-list-反转和排序"><a href="#3-7-7-list-反转和排序" class="headerlink" title="3.7.7 list 反转和排序"></a>3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器中的元素反转，以及将容器中的数据进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reverse();</code>   //反转链表</li>
<li><code>sort();</code>        //链表排序</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">void printList(const list&lt;int&gt;&amp; L) &#123;

    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

bool myCompare(int val1 , int val2)
&#123;
    return val1 &gt; val2;
&#125;

//反转和排序
void test01()
&#123;
    list&lt;int&gt; L;
    L.push_back(90);
    L.push_back(30);
    L.push_back(20);
    L.push_back(70);
    printList(L);

    //反转容器的元素
    L.reverse();
    printList(L);

    //排序
    L.sort(); //默认的排序规则 从小到大
    printList(L);

    L.sort(myCompare); //指定规则，从大到小
    printList(L);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>反转   — reverse</li>
<li>排序   — sort （成员函数）</li>
</ul>
<h4 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p>
<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;list&gt;
#include &lt;string&gt;
class Person &#123;
public:
    Person(string name, int age , int height) &#123;
        m_Name = name;
        m_Age = age;
        m_Height = height;
    &#125;

public:
    string m_Name;  //姓名
    int m_Age;      //年龄
    int m_Height;   //身高
&#125;;


bool ComparePerson(Person&amp; p1, Person&amp; p2) &#123;

    if (p1.m_Age == p2.m_Age) &#123;
        return p1.m_Height  &gt; p2.m_Height;
    &#125;
    else
    &#123;
        return  p1.m_Age &lt; p2.m_Age;
    &#125;

&#125;

void test01() &#123;

    list&lt;Person&gt; L;

    Person p1(&quot;刘备&quot;, 35 , 175);
    Person p2(&quot;曹操&quot;, 45 , 180);
    Person p3(&quot;孙权&quot;, 40 , 170);
    Person p4(&quot;赵云&quot;, 25 , 190);
    Person p5(&quot;张飞&quot;, 35 , 160);
    Person p6(&quot;关羽&quot;, 35 , 200);

    L.push_back(p1);
    L.push_back(p2);
    L.push_back(p3);
    L.push_back(p4);
    L.push_back(p5);
    L.push_back(p6);

    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;
        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age 
              &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;
    &#125;

    cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;
    L.sort(ComparePerson); //排序

    for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;
        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age 
              &lt;&lt; &quot; 身高： &quot; &lt;&lt; it-&gt;m_Height &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li>
</ul>
<ul>
<li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li>
</ul>
<h3 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set/ multiset 容器"></a>3.8 set/ multiset 容器</h3><h4 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h4><p><strong>简介：</strong></p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li>
</ul>
<p><strong>set和multiset区别</strong>：</p>
<ul>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<h4 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p>
<p>构造：</p>
<ul>
<li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li>
<li><code>set(const set &amp;st);</code>       //拷贝构造函数</li>
</ul>
<p>赋值：</p>
<ul>
<li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;set&gt;

void printSet(set&lt;int&gt; &amp; s)
&#123;
    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)
    &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

//构造和赋值
void test01()
&#123;
    set&lt;int&gt; s1;

    s1.insert(10);
    s1.insert(30);
    s1.insert(20);
    s1.insert(40);
    printSet(s1);

    //拷贝构造
    set&lt;int&gt;s2(s1);
    printSet(s2);

    //赋值
    set&lt;int&gt;s3;
    s3 = s2;
    printSet(s3);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<h4 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计set容器大小以及交换set容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>size();</code>          //返回容器中元素的数目</li>
<li><code>empty();</code>        //判断容器是否为空</li>
<li><code>swap(st);</code>      //交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;set&gt;

void printSet(set&lt;int&gt; &amp; s)
&#123;
    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)
    &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

//大小
void test01()
&#123;

    set&lt;int&gt; s1;
    
    s1.insert(10);
    s1.insert(30);
    s1.insert(20);
    s1.insert(40);

    if (s1.empty())
    &#123;
        cout &lt;&lt; &quot;s1为空&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;s1不为空&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;s1的大小为： &quot; &lt;&lt; s1.size() &lt;&lt; endl;
    &#125;

&#125;

//交换
void test02()
&#123;
    set&lt;int&gt; s1;

    s1.insert(10);
    s1.insert(30);
    s1.insert(20);
    s1.insert(40);

    set&lt;int&gt; s2;

    s2.insert(100);
    s2.insert(300);
    s2.insert(200);
    s2.insert(400);

    cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;
    printSet(s1);
    printSet(s2);
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;
    s1.swap(s2);
    printSet(s1);
    printSet(s2);
&#125;

int main() &#123;

    //test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>set容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           //在容器中插入元素。</li>
<li><code>clear();</code>                    //清除所有元素</li>
<li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;set&gt;

void printSet(set&lt;int&gt; &amp; s)
&#123;
    for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++)
    &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

//插入和删除
void test01()
&#123;
    set&lt;int&gt; s1;
    //插入
    s1.insert(10);
    s1.insert(30);
    s1.insert(20);
    s1.insert(40);
    printSet(s1);

    //删除
    s1.erase(s1.begin());
    printSet(s1);

    s1.erase(30);
    printSet(s1);

    //清空
    //s1.erase(s1.begin(), s1.end());
    s1.clear();
    printSet(s1);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对set容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                //统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;set&gt;

//查找和统计
void test01()
&#123;
    set&lt;int&gt; s1;
    //插入
    s1.insert(10);
    s1.insert(30);
    s1.insert(20);
    s1.insert(40);
    
    //查找
    set&lt;int&gt;::iterator pos = s1.find(30);

    if (pos != s1.end())
    &#123;
        cout &lt;&lt; &quot;找到了元素 ： &quot; &lt;&lt; *pos &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;
    &#125;

    //统计
    int num = s1.count(30);
    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于set，结果为0或者1）</li>
</ul>
<h4 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p>
<ul>
<li>掌握set和multiset的区别</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;set&gt;

//set和multiset区别
void test01()
&#123;
    set&lt;int&gt; s;
    pair&lt;set&lt;int&gt;::iterator, bool&gt;  ret = s.insert(10);
    if (ret.second) &#123;
        cout &lt;&lt; &quot;第一次插入成功!&quot; &lt;&lt; endl;
    &#125;
    else &#123;
        cout &lt;&lt; &quot;第一次插入失败!&quot; &lt;&lt; endl;
    &#125;

    ret = s.insert(10);
    if (ret.second) &#123;
        cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;
    &#125;
    else &#123;
        cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;
    &#125;
    
    //multiset
    multiset&lt;int&gt; ms;
    ms.insert(10);
    ms.insert(10);

    for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h4 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p><strong>两种创建方式：</strong></p>
<ul>
<li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li>
<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;string&gt;

//对组创建
void test01()
&#123;
    pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);
    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt;  p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;

    pair&lt;string, int&gt; p2 = make_pair(&quot;Jerry&quot;, 10);
    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p2.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p2.second &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<p>两种方式都可以创建对组，记住一种即可</p>
<h4 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h4><p>学习目标：</p>
<ul>
<li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li>
</ul>
<p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例一</strong>   set存放内置数据类型</p>
<pre><code class="C++">#include &lt;set&gt;

class MyCompare 
&#123;
public:
    bool operator()(int v1, int v2) &#123;
        return v1 &gt; v2;
    &#125;
&#125;;
void test01() 
&#123;    
    set&lt;int&gt; s1;
    s1.insert(10);
    s1.insert(40);
    s1.insert(20);
    s1.insert(30);
    s1.insert(50);

    //默认从小到大
    for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;

    //指定排序规则
    set&lt;int,MyCompare&gt; s2;
    s2.insert(10);
    s2.insert(40);
    s2.insert(20);
    s2.insert(30);
    s2.insert(50);

    for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：利用仿函数可以指定set容器的排序规则</p>
<p><strong>示例二</strong> set存放自定义数据类型</p>
<pre><code class="C++">#include &lt;set&gt;
#include &lt;string&gt;

class Person
&#123;
public:
    Person(string name, int age)
    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;

    string m_Name;
    int m_Age;

&#125;;
class comparePerson
&#123;
public:
    bool operator()(const Person&amp; p1, const Person &amp;p2)
    &#123;
        //按照年龄进行排序  降序
        return p1.m_Age &gt; p2.m_Age;
    &#125;
&#125;;

void test01()
&#123;
    set&lt;Person, comparePerson&gt; s;

    Person p1(&quot;刘备&quot;, 23);
    Person p2(&quot;关羽&quot;, 27);
    Person p3(&quot;张飞&quot;, 25);
    Person p4(&quot;赵云&quot;, 21);

    s.insert(p1);
    s.insert(p2);
    s.insert(p3);
    s.insert(p4);

    for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)
    &#123;
        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
    &#125;
&#125;
int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h3 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map/ multimap容器"></a>3.9 map/ multimap容器</h3><h4 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h4><p><strong>简介：</strong></p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap<strong>区别</strong>：</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h4 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行构造和赋值操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><strong>构造：</strong></p>
<ul>
<li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数: </li>
<li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li>
</ul>
<p><strong>赋值：</strong></p>
<ul>
<li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;map&gt;

void printMap(map&lt;int,int&gt;&amp;m)
&#123;
    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)
    &#123;
        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
    &#125;
    cout &lt;&lt; endl;
&#125;

void test01()
&#123;
    map&lt;int,int&gt;m; //默认构造
    m.insert(pair&lt;int, int&gt;(1, 10));
    m.insert(pair&lt;int, int&gt;(2, 20));
    m.insert(pair&lt;int, int&gt;(3, 30));
    printMap(m);

    map&lt;int, int&gt;m2(m); //拷贝构造
    printMap(m2);

    map&lt;int, int&gt;m3;
    m3 = m2; //赋值
    printMap(m3);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p>
<h4 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计map容器大小以及交换map容器</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>size();</code>          //返回容器中元素的数目</li>
<li><code>empty();</code>        //判断容器是否为空</li>
<li><code>swap(st);</code>      //交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;map&gt;

void printMap(map&lt;int,int&gt;&amp;m)
&#123;
    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)
    &#123;
        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
    &#125;
    cout &lt;&lt; endl;
&#125;

void test01()
&#123;
    map&lt;int, int&gt;m;
    m.insert(pair&lt;int, int&gt;(1, 10));
    m.insert(pair&lt;int, int&gt;(2, 20));
    m.insert(pair&lt;int, int&gt;(3, 30));

    if (m.empty())
    &#123;
        cout &lt;&lt; &quot;m为空&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;m不为空&quot; &lt;&lt; endl;
        cout &lt;&lt; &quot;m的大小为： &quot; &lt;&lt; m.size() &lt;&lt; endl;
    &#125;
&#125;


//交换
void test02()
&#123;
    map&lt;int, int&gt;m;
    m.insert(pair&lt;int, int&gt;(1, 10));
    m.insert(pair&lt;int, int&gt;(2, 20));
    m.insert(pair&lt;int, int&gt;(3, 30));

    map&lt;int, int&gt;m2;
    m2.insert(pair&lt;int, int&gt;(4, 100));
    m2.insert(pair&lt;int, int&gt;(5, 200));
    m2.insert(pair&lt;int, int&gt;(6, 300));

    cout &lt;&lt; &quot;交换前&quot; &lt;&lt; endl;
    printMap(m);
    printMap(m2);

    cout &lt;&lt; &quot;交换后&quot; &lt;&lt; endl;
    m.swap(m2);
    printMap(m);
    printMap(m2);
&#125;

int main() &#123;

    test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h4 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p>
<ul>
<li>map容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           //在容器中插入元素。</li>
<li><code>clear();</code>                    //清除所有元素</li>
<li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(key);</code>            //删除容器中值为key的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;map&gt;

void printMap(map&lt;int,int&gt;&amp;m)
&#123;
    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++)
    &#123;
        cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
    &#125;
    cout &lt;&lt; endl;
&#125;

void test01()
&#123;
    //插入
    map&lt;int, int&gt; m;
    //第一种插入方式
    m.insert(pair&lt;int, int&gt;(1, 10));
    //第二种插入方式
    m.insert(make_pair(2, 20));
    //第三种插入方式
    m.insert(map&lt;int, int&gt;::value_type(3, 30));
    //第四种插入方式
    m[4] = 40; 
    printMap(m);

    //删除
    m.erase(m.begin());
    printMap(m);

    m.erase(3);
    printMap(m);

    //清空
    m.erase(m.begin(),m.end());
    m.clear();
    printMap(m);
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>map插入方式很多，记住其一即可</li>
</ul>
<ul>
<li>插入   — insert </li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>                //统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;map&gt;

//查找和统计
void test01()
&#123;
    map&lt;int, int&gt;m; 
    m.insert(pair&lt;int, int&gt;(1, 10));
    m.insert(pair&lt;int, int&gt;(2, 20));
    m.insert(pair&lt;int, int&gt;(3, 30));

    //查找
    map&lt;int, int&gt;::iterator pos = m.find(3);

    if (pos != m.end())
    &#123;
        cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; (*pos).first &lt;&lt; &quot; value = &quot; &lt;&lt; (*pos).second &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;未找到元素&quot; &lt;&lt; endl;
    &#125;

    //统计
    int num = m.count(3);
    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于map，结果为0或者1）</li>
</ul>
<h4 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p>
<ul>
<li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li>
</ul>
<p><strong>主要技术点:</strong></p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;map&gt;

class MyCompare &#123;
public:
    bool operator()(int v1, int v2) &#123;
        return v1 &gt; v2;
    &#125;
&#125;;

void test01() 
&#123;
    //默认从小到大排序
    //利用仿函数实现从大到小排序
    map&lt;int, int, MyCompare&gt; m;

    m.insert(make_pair(1, 10));
    m.insert(make_pair(2, 20));
    m.insert(make_pair(3, 30));
    m.insert(make_pair(4, 40));
    m.insert(make_pair(5, 50));

    for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;
        cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
    &#125;
&#125;
int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则,同set容器</li>
</ul>
<h3 id="3-10-案例-员工分组"><a href="#3-10-案例-员工分组" class="headerlink" title="3.10 案例-员工分组"></a>3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述"><a href="#3-10-1-案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h4><ul>
<li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li>
<li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过multimap进行信息的插入  key(部门编号) value(员工)</li>
<li>分部门显示员工信息</li>
</ul>
<h4 id="3-10-2-实现步骤"><a href="#3-10-2-实现步骤" class="headerlink" title="3.10.2 实现步骤"></a>3.10.2 实现步骤</h4><ol>
<li>创建10名员工，放到vector中</li>
<li>遍历vector容器，取出每个员工，进行随机分组</li>
<li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li>
<li>分部门显示员工信息</li>
</ol>
<p><strong>案例代码：</strong></p>
<pre><code class="C++">#include&lt;iostream&gt;
using namespace std;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;ctime&gt;

/*
- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作
- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发
- 随机给10名员工分配部门和工资
- 通过multimap进行信息的插入  key(部门编号) value(员工)
- 分部门显示员工信息
*/

#define CEHUA  0
#define MEISHU 1
#define YANFA  2

class Worker
&#123;
public:
    string m_Name;
    int m_Salary;
&#125;;

void createWorker(vector&lt;Worker&gt;&amp;v)
&#123;
    string nameSeed = &quot;ABCDEFGHIJ&quot;;
    for (int i = 0; i &lt; 10; i++)
    &#123;
        Worker worker;
        worker.m_Name = &quot;员工&quot;;
        worker.m_Name += nameSeed[i];

        worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999
        //将员工放入到容器中
        v.push_back(worker);
    &#125;
&#125;

//员工分组
void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m)
&#123;
    for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)
    &#123;
        //产生随机部门编号
        int deptId = rand() % 3; // 0 1 2 

        //将员工插入到分组中
        //key部门编号，value具体员工
        m.insert(make_pair(deptId, *it));
    &#125;
&#125;

void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)
&#123;
    // 0  A  B  C   1  D  E   2  F G ...
    cout &lt;&lt; &quot;策划部门：&quot; &lt;&lt; endl;

    multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA);
    int count = m.count(CEHUA); // 统计具体人数
    int index = 0;
    for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)
    &#123;
        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
    &#125;

    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;美术部门： &quot; &lt;&lt; endl;
    pos = m.find(MEISHU);
    count = m.count(MEISHU); // 统计具体人数
    index = 0;
    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)
    &#123;
        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
    &#125;

    cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;研发部门： &quot; &lt;&lt; endl;
    pos = m.find(YANFA);
    count = m.count(YANFA); // 统计具体人数
    index = 0;
    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)
    &#123;
        cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
    &#125;

&#125;

int main() &#123;

    srand((unsigned int)time(NULL));

    //1、创建员工
    vector&lt;Worker&gt;vWorker;
    createWorker(vWorker);

    //2、员工分组
    multimap&lt;int, Worker&gt;mWorker;
    setGroup(vWorker, mWorker);


    //3、分组显示员工
    showWorkerByGourp(mWorker);

    ////测试
    //for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)
    //&#123;
    //    cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;
    //&#125;

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>当数据以键值对形式存在，可以考虑用map 或 multimap</li>
</ul>
<h2 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL- 函数对象"></a>4 STL- 函数对象</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h4><p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li>
</ul>
<p><strong>本质：</strong></p>
<p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p>
<h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h4><p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="C++">#include &lt;string&gt;

//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值
class MyAdd
&#123;
public :
    int operator()(int v1,int v2)
    &#123;
        return v1 + v2;
    &#125;
&#125;;

void test01()
&#123;
    MyAdd myAdd;
    cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;
&#125;

//2、函数对象可以有自己的状态
class MyPrint
&#123;
public:
    MyPrint()
    &#123;
        count = 0;
    &#125;
    void operator()(string test)
    &#123;
        cout &lt;&lt; test &lt;&lt; endl;
        count++; //统计使用次数
    &#125;

    int count; //内部自己的状态
&#125;;
void test02()
&#123;
    MyPrint myPrint;
    myPrint(&quot;hello world&quot;);
    myPrint(&quot;hello world&quot;);
    myPrint(&quot;hello world&quot;);
    cout &lt;&lt; &quot;myPrint调用次数为： &quot; &lt;&lt; myPrint.count &lt;&lt; endl;
&#125;

//3、函数对象可以作为参数传递
void doPrint(MyPrint &amp;mp , string test)
&#123;
    mp(test);
&#125;

void test03()
&#123;
    MyPrint myPrint;
    doPrint(myPrint, &quot;Hello C++&quot;);
&#125;

int main() &#123;

    //test01();
    //test02();
    test03();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：</p>
<ul>
<li>仿函数写法非常灵活，可以作为参数进行传递。</li>
</ul>
<h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p>
<ul>
<li>返回bool类型的仿函数称为<strong>谓词</strong></li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

//1.一元谓词
struct GreaterFive&#123;
    bool operator()(int val) &#123;
        return val &gt; 5;
    &#125;
&#125;;

void test01() &#123;

    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10; i++)
    &#123;
        v.push_back(i);
    &#125;

    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());
    if (it == v.end()) &#123;
        cout &lt;&lt; &quot;没找到!&quot; &lt;&lt; endl;
    &#125;
    else &#123;
        cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;
    &#125;

&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：参数只有一个的谓词，称为一元谓词</p>
<h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;
//二元谓词
class MyCompare
&#123;
public:
    bool operator()(int num1, int num2)
    &#123;
        return num1 &gt; num2;
    &#125;
&#125;;

void test01()
&#123;
    vector&lt;int&gt; v;
    v.push_back(10);
    v.push_back(40);
    v.push_back(20);
    v.push_back(30);
    v.push_back(50);

    //默认从小到大
    sort(v.begin(), v.end());
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
    &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;

    //使用函数对象改变算法策略，排序从大到小
    sort(v.begin(), v.end(), MyCompare());
    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
    &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：参数只有两个的谓词，称为二元谓词</p>
<h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p><strong>分类:</strong></p>
<ul>
<li><p>算术仿函数</p>
</li>
<li><p>关系仿函数</p>
</li>
<li><p>逻辑仿函数</p>
</li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li>
</ul>
<h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;functional&gt;
//negate
void test01()
&#123;
    negate&lt;int&gt; n;
    cout &lt;&lt; n(50) &lt;&lt; endl;
&#125;

//plus
void test02()
&#123;
    plus&lt;int&gt; p;
    cout &lt;&lt; p(10, 20) &lt;&lt; endl;
&#125;

int main() &#123;

    test01();
    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p>
<h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现关系对比</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li>
<li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li>
<li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li>
<li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class MyCompare
&#123;
public:
    bool operator()(int v1,int v2)
    &#123;
        return v1 &gt; v2;
    &#125;
&#125;;
void test01()
&#123;
    vector&lt;int&gt; v;

    v.push_back(10);
    v.push_back(30);
    v.push_back(50);
    v.push_back(40);
    v.push_back(20);

    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;

    //自己实现仿函数
    //sort(v.begin(), v.end(), MyCompare());
    //STL内建仿函数  大于仿函数
    sort(v.begin(), v.end(), greater&lt;int&gt;());

    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p>
<h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
void test01()
&#123;
    vector&lt;bool&gt; v;
    v.push_back(true);
    v.push_back(false);
    v.push_back(true);
    v.push_back(false);

    for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++)
    &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;

    //逻辑非  将v容器搬运到v2中，并执行逻辑非运算
    vector&lt;bool&gt; v2;
    v2.resize(v.size());
    transform(v.begin(), v.end(),  v2.begin(), logical_not&lt;bool&gt;());
    for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++)
    &#123;
        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    &#125;
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：逻辑仿函数实际应用较少，了解即可</p>
<h2 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h2><p><strong>概述</strong>:</p>
<ul>
<li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li>
</ul>
<ul>
<li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li>
<li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li>
</ul>
<h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的遍历算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>for_each</code>     //遍历容器</li>
<li><code>transform</code>   //搬运容器到另一个容器中</li>
</ul>
<h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><p><strong>功能描述：</strong></p>
<ul>
<li>实现遍历容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>for_each(iterator beg, iterator end, _func);  </code></p>
<p>// 遍历算法 遍历容器元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _func 函数或者函数对象</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

//普通函数
void print01(int val) 
&#123;
    cout &lt;&lt; val &lt;&lt; &quot; &quot;;
&#125;
//函数对象
class print02 
&#123;
 public:
    void operator()(int val) 
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

//for_each算法基本用法
void test01() &#123;

    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10; i++) 
    &#123;
        v.push_back(i);
    &#125;

    //遍历算法
    for_each(v.begin(), v.end(), print01);
    cout &lt;&lt; endl;

    for_each(v.begin(), v.end(), print02());
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p>
<h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><p><strong>功能描述：</strong></p>
<ul>
<li>搬运容器到另一个容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li>
</ul>
<p>//beg1 源容器开始迭代器</p>
<p>//end1 源容器结束迭代器</p>
<p>//beg2 目标容器开始迭代器</p>
<p>//_func 函数或者函数对象</p>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include&lt;vector&gt;
#include&lt;algorithm&gt;

//常用遍历算法  搬运 transform

class TransForm
&#123;
public:
    int operator()(int val)
    &#123;
        return val;
    &#125;

&#125;;

class MyPrint
&#123;
public:
    void operator()(int val)
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01()
&#123;
    vector&lt;int&gt;v;
    for (int i = 0; i &lt; 10; i++)
    &#123;
        v.push_back(i);
    &#125;

    vector&lt;int&gt;vTarget; //目标容器

    vTarget.resize(v.size()); // 目标容器需要提前开辟空间

    transform(v.begin(), v.end(), vTarget.begin(), TransForm());

    for_each(vTarget.begin(), vTarget.end(), MyPrint());
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h3 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h3><p>学习目标：</p>
<ul>
<li>掌握常用的查找算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>find</code>                     //查找元素</li>
<li><code>find_if</code>               //按条件查找元素</li>
<li><code>adjacent_find</code>    //查找相邻重复元素</li>
<li><code>binary_search</code>    //二分查找法</li>
<li><code>count</code>                   //统计元素个数</li>
<li><code>count_if</code>             //按条件统计元素个数</li>
</ul>
<h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find(iterator beg, iterator end, value);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
void test01() &#123;

    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10; i++) &#123;
        v.push_back(i + 1);
    &#125;
    //查找容器中是否有 5 这个元素
    vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5);
    if (it == v.end()) 
    &#123;
        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
    &#125;
    else 
    &#123;
        cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;
    &#125;
&#125;

class Person &#123;
public:
    Person(string name, int age) 
    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;
    //重载==
    bool operator==(const Person&amp; p) 
    &#123;
        if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) 
        &#123;
            return true;
        &#125;
        return false;
    &#125;

public:
    string m_Name;
    int m_Age;
&#125;;

void test02() &#123;

    vector&lt;Person&gt; v;

    //创建数据
    Person p1(&quot;aaa&quot;, 10);
    Person p2(&quot;bbb&quot;, 20);
    Person p3(&quot;ccc&quot;, 30);
    Person p4(&quot;ddd&quot;, 40);

    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);

    vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);
    if (it == v.end()) 
    &#123;
        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
    &#125;
    else 
    &#123;
        cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
<p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p>
<h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li>按条件查找元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

//内置数据类型
class GreaterFive
&#123;
public:
    bool operator()(int val)
    &#123;
        return val &gt; 5;
    &#125;
&#125;;

void test01() &#123;

    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 10; i++) &#123;
        v.push_back(i + 1);
    &#125;

    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());
    if (it == v.end()) &#123;
        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
    &#125;
    else &#123;
        cout &lt;&lt; &quot;找到大于5的数字:&quot; &lt;&lt; *it &lt;&lt; endl;
    &#125;
&#125;

//自定义数据类型
class Person &#123;
public:
    Person(string name, int age)
    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;
public:
    string m_Name;
    int m_Age;
&#125;;

class Greater20
&#123;
public:
    bool operator()(Person &amp;p)
    &#123;
        return p.m_Age &gt; 20;
    &#125;

&#125;;

void test02() &#123;

    vector&lt;Person&gt; v;

    //创建数据
    Person p1(&quot;aaa&quot;, 10);
    Person p2(&quot;bbb&quot;, 20);
    Person p3(&quot;ccc&quot;, 30);
    Person p4(&quot;ddd&quot;, 40);

    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);

    vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());
    if (it == v.end())
    &#123;
        cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;

    //test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
<h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>adjacent_find(iterator beg, iterator end);  </code></p>
<p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

void test01()
&#123;
    vector&lt;int&gt; v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(5);
    v.push_back(2);
    v.push_back(4);
    v.push_back(4);
    v.push_back(3);

    //查找相邻重复元素
    vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end());
    if (it == v.end()) &#123;
        cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;
    &#125;
    else &#123;
        cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
<p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p>
<h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素是否存在</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p>
<p>// 查找指定的元素，查到 返回true  否则false</p>
<p>// 注意: 在<strong>无序序列中不可用</strong></p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

void test01()
&#123;
    vector&lt;int&gt;v;

    for (int i = 0; i &lt; 10; i++)
    &#123;
        v.push_back(i);
    &#125;
    //二分查找
    bool ret = binary_search(v.begin(), v.end(),2);
    if (ret)
    &#123;
        cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;
    &#125;
    else
    &#123;
        cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
    &#125;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>
<h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p>
<ul>
<li>统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count(iterator beg, iterator end, value);  </code></p>
<p>// 统计元素出现次数</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 统计的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

//内置数据类型
void test01()
&#123;
    vector&lt;int&gt; v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(4);
    v.push_back(5);
    v.push_back(3);
    v.push_back(4);
    v.push_back(4);

    int num = count(v.begin(), v.end(), 4);

    cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;
&#125;

//自定义数据类型
class Person
&#123;
public:
    Person(string name, int age)
    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;
    bool operator==(const Person &amp; p)
    &#123;
        if (this-&gt;m_Age == p.m_Age)
        &#123;
            return true;
        &#125;
        else
        &#123;
            return false;
        &#125;
    &#125;
    string m_Name;
    int m_Age;
&#125;;

void test02()
&#123;
    vector&lt;Person&gt; v;

    Person p1(&quot;刘备&quot;, 35);
    Person p2(&quot;关羽&quot;, 35);
    Person p3(&quot;张飞&quot;, 35);
    Person p4(&quot;赵云&quot;, 30);
    Person p5(&quot;曹操&quot;, 25);

    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);
    v.push_back(p5);
    
    Person p(&quot;诸葛亮&quot;,35);

    int num = count(v.begin(), v.end(), p);
    cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
&#125;
int main() &#123;

    //test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p>
<h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p>
<ul>
<li>按条件统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按条件统计元素出现次数</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _Pred 谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class Greater4
&#123;
public:
    bool operator()(int val)
    &#123;
        return val &gt;= 4;
    &#125;
&#125;;

//内置数据类型
void test01()
&#123;
    vector&lt;int&gt; v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(4);
    v.push_back(5);
    v.push_back(3);
    v.push_back(4);
    v.push_back(4);

    int num = count_if(v.begin(), v.end(), Greater4());

    cout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;
&#125;

//自定义数据类型
class Person
&#123;
public:
    Person(string name, int age)
    &#123;
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    &#125;

    string m_Name;
    int m_Age;
&#125;;

class AgeLess35
&#123;
public:
    bool operator()(const Person &amp;p)
    &#123;
        return p.m_Age &lt; 35;
    &#125;
&#125;;
void test02()
&#123;
    vector&lt;Person&gt; v;

    Person p1(&quot;刘备&quot;, 35);
    Person p2(&quot;关羽&quot;, 35);
    Person p3(&quot;张飞&quot;, 35);
    Person p4(&quot;赵云&quot;, 30);
    Person p5(&quot;曹操&quot;, 25);

    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);
    v.push_back(p5);

    int num = count_if(v.begin(), v.end(), AgeLess35());
    cout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;
&#125;


int main() &#123;

    //test01();

    test02();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p>
<h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的排序算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>sort</code>             //对容器内元素进行排序</li>
<li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li>
<li><code>merge </code>           // 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code>       // 反转指定范围的元素</li>
</ul>
<h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p>
<ul>
<li>对容器内元素进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>//  beg    开始迭代器</p>
<p>//  end    结束迭代器</p>
<p>// _Pred  谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

void myPrint(int val)
&#123;
    cout &lt;&lt; val &lt;&lt; &quot; &quot;;
&#125;

void test01() &#123;
    vector&lt;int&gt; v;
    v.push_back(10);
    v.push_back(30);
    v.push_back(50);
    v.push_back(20);
    v.push_back(40);

    //sort默认从小到大排序
    sort(v.begin(), v.end());
    for_each(v.begin(), v.end(), myPrint);
    cout &lt;&lt; endl;

    //从大到小排序
    sort(v.begin(), v.end(), greater&lt;int&gt;());
    for_each(v.begin(), v.end(), myPrint);
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p>
<h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p>
<ul>
<li>洗牌   指定范围内的元素随机调整次序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>random_shuffle(iterator beg, iterator end);  </code></p>
<p>// 指定范围内的元素随机调整次序</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;ctime&gt;

class myPrint
&#123;
public:
    void operator()(int val)
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01()
&#123;
    srand((unsigned int)time(NULL));
    vector&lt;int&gt; v;
    for(int i = 0 ; i &lt; 10;i++)
    &#123;
        v.push_back(i);
    &#125;
    for_each(v.begin(), v.end(), myPrint());
    cout &lt;&lt; endl;

    //打乱顺序
    random_shuffle(v.begin(), v.end());
    for_each(v.begin(), v.end(), myPrint());
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p>
<h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p>
<ul>
<li>两个容器元素合并，并存储到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 容器元素合并，并存储到另一容器中</p>
<p>// 注意: 两个容器必须是<strong>有序的</strong></p>
<p>// beg1   容器1开始迭代器<br>// end1   容器1结束迭代器<br>// beg2   容器2开始迭代器<br>// end2   容器2结束迭代器<br>// dest    目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
&#123;
public:
    void operator()(int val)
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01()
&#123;
    vector&lt;int&gt; v1;
    vector&lt;int&gt; v2;
    for (int i = 0; i &lt; 10 ; i++) 
    &#123;
        v1.push_back(i);
        v2.push_back(i + 1);
    &#125;

    vector&lt;int&gt; vtarget;
    //目标容器需要提前开辟空间
    vtarget.resize(v1.size() + v2.size());
    //合并  需要两个有序序列
    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());
    for_each(vtarget.begin(), vtarget.end(), myPrint());
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p>
<h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内元素进行反转</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>reverse(iterator beg, iterator end);  </code></p>
<p>// 反转指定范围的元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
&#123;
public:
    void operator()(int val)
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01()
&#123;
    vector&lt;int&gt; v;
    v.push_back(10);
    v.push_back(30);
    v.push_back(50);
    v.push_back(20);
    v.push_back(40);

    cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;
    for_each(v.begin(), v.end(), myPrint());
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;

    reverse(v.begin(), v.end());
    for_each(v.begin(), v.end(), myPrint());
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p>
<h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的拷贝和替换算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中</li>
<li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if </code>          // 容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code>                     // 互换两个容器的元素</li>
</ul>
<h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p>
<ul>
<li>容器内指定范围的元素拷贝到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg  开始迭代器</p>
<p>// end  结束迭代器</p>
<p>// dest 目标起始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
&#123;
public:
    void operator()(int val)
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01()
&#123;
    vector&lt;int&gt; v1;
    for (int i = 0; i &lt; 10; i++) &#123;
        v1.push_back(i + 1);
    &#125;
    vector&lt;int&gt; v2;
    v2.resize(v1.size());
    copy(v1.begin(), v1.end(), v2.begin());

    for_each(v2.begin(), v2.end(), myPrint());
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p>
<h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内指定范围的旧元素修改为新元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p>
<p>// 将区间内旧元素 替换成 新元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// oldvalue 旧元素</p>
<p>// newvalue 新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
&#123;
public:
    void operator()(int val)
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01()
&#123;
    vector&lt;int&gt; v;
    v.push_back(20);
    v.push_back(30);
    v.push_back(20);
    v.push_back(40);
    v.push_back(50);
    v.push_back(10);
    v.push_back(20);

    cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;
    for_each(v.begin(), v.end(), myPrint());
    cout &lt;&lt; endl;

    //将容器中的20 替换成 2000
    cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;
    replace(v.begin(), v.end(), 20,2000);
    for_each(v.begin(), v.end(), myPrint());
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>replace会替换区间内满足条件的元素</p>
<h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong>  </p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p>
<p>// 按条件替换元素，满足条件的替换成指定元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _pred 谓词</p>
<p>// newvalue 替换的新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
&#123;
public:
    void operator()(int val)
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

class ReplaceGreater30
&#123;
public:
    bool operator()(int val)
    &#123;
        return val &gt;= 30;
    &#125;

&#125;;

void test01()
&#123;
    vector&lt;int&gt; v;
    v.push_back(20);
    v.push_back(30);
    v.push_back(20);
    v.push_back(40);
    v.push_back(50);
    v.push_back(10);
    v.push_back(20);

    cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;
    for_each(v.begin(), v.end(), myPrint());
    cout &lt;&lt; endl;

    //将容器中大于等于的30 替换成 3000
    cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;
    replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000);
    for_each(v.begin(), v.end(), myPrint());
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p>
<ul>
<li>互换两个容器的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>swap(container c1, container c2);  </code></p>
<p>// 互换两个容器的元素</p>
<p>// c1容器1</p>
<p>// c2容器2</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="c++">#include &lt;algorithm&gt;
#include &lt;vector&gt;

class myPrint
&#123;
public:
    void operator()(int val)
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01()
&#123;
    vector&lt;int&gt; v1;
    vector&lt;int&gt; v2;
    for (int i = 0; i &lt; 10; i++) &#123;
        v1.push_back(i);
        v2.push_back(i+100);
    &#125;

    cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;
    for_each(v1.begin(), v1.end(), myPrint());
    cout &lt;&lt; endl;
    for_each(v2.begin(), v2.end(), myPrint());
    cout &lt;&lt; endl;

    cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;
    swap(v1, v2);
    for_each(v1.begin(), v1.end(), myPrint());
    cout &lt;&lt; endl;
    for_each(v2.begin(), v2.end(), myPrint());
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p>
<h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的算术生成算法</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>accumulate</code>      // 计算容器元素累计总和</p>
</li>
<li><p><code>fill</code>                 // 向容器中添加元素</p>
</li>
</ul>
<h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p>
<ul>
<li> 计算区间内 容器元素累计总和</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>accumulate(iterator beg, iterator end, value);  </code></p>
<p>// 计算容器元素累计总和</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 起始值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="c++">#include &lt;numeric&gt;
#include &lt;vector&gt;
void test01()
&#123;
    vector&lt;int&gt; v;
    for (int i = 0; i &lt;= 100; i++) &#123;
        v.push_back(i);
    &#125;

    int total = accumulate(v.begin(), v.end(), 0);

    cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p>
<h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p>
<ul>
<li>向容器中填充指定的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>fill(iterator beg, iterator end, value);  </code></p>
<p>// 向容器中填充元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 填充的值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="c++">#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

class myPrint
&#123;
public:
    void operator()(int val)
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01()
&#123;

    vector&lt;int&gt; v;
    v.resize(10);
    //填充
    fill(v.begin(), v.end(), 100);

    for_each(v.begin(), v.end(), myPrint());
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p>
<h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p>
<ul>
<li>掌握常用的集合算法</li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>set_intersection</code>          // 求两个容器的交集</p>
</li>
<li><p><code>set_union</code>                       // 求两个容器的并集</p>
</li>
<li><p><code>set_difference </code>              // 求两个容器的差集</p>
</li>
</ul>
<h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个容器的交集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 求两个集合的交集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

class myPrint
&#123;
public:
    void operator()(int val)
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01()
&#123;
    vector&lt;int&gt; v1;
    vector&lt;int&gt; v2;
    for (int i = 0; i &lt; 10; i++)
    &#123;
        v1.push_back(i);
        v2.push_back(i+5);
    &#125;

    vector&lt;int&gt; vTarget;
    //取两个里面较小的值给目标容器开辟空间
    vTarget.resize(min(v1.size(), v2.size()));

    //返回目标容器的最后一个元素的迭代器地址
    vector&lt;int&gt;::iterator itEnd = 
        set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());

    for_each(vTarget.begin(), itEnd, myPrint());
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong> </p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的并集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 求两个集合的并集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

class myPrint
&#123;
public:
    void operator()(int val)
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01()
&#123;
    vector&lt;int&gt; v1;
    vector&lt;int&gt; v2;
    for (int i = 0; i &lt; 10; i++) &#123;
        v1.push_back(i);
        v2.push_back(i+5);
    &#125;

    vector&lt;int&gt; vTarget;
    //取两个容器的和给目标容器开辟空间
    vTarget.resize(v1.size() + v2.size());

    //返回目标容器的最后一个元素的迭代器地址
    vector&lt;int&gt;::iterator itEnd = 
        set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());

    for_each(vTarget.begin(), itEnd, myPrint());
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong> </p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的差集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>// 求两个集合的差集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong></p>
<p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code class="C++">#include &lt;vector&gt;
#include &lt;algorithm&gt;

class myPrint
&#123;
public:
    void operator()(int val)
    &#123;
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    &#125;
&#125;;

void test01()
&#123;
    vector&lt;int&gt; v1;
    vector&lt;int&gt; v2;
    for (int i = 0; i &lt; 10; i++) &#123;
        v1.push_back(i);
        v2.push_back(i+5);
    &#125;

    vector&lt;int&gt; vTarget;
    //取两个里面较大的值给目标容器开辟空间
    vTarget.resize( max(v1.size() , v2.size()));

    //返回目标容器的最后一个元素的迭代器地址
    cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;
    vector&lt;int&gt;::iterator itEnd = 
        set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
    for_each(vTarget.begin(), itEnd, myPrint());
    cout &lt;&lt; endl;


    cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;
    itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());
    for_each(vTarget.begin(), itEnd, myPrint());
    cout &lt;&lt; endl;
&#125;

int main() &#123;

    test01();

    system(&quot;pause&quot;);

    return 0;
&#125;
</code></pre>
<p><strong>总结：</strong> </p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>

            </div>
        </article>
    </div>
    <br>
    
        <div class="next-prev-post">
            
            
                <div class="next-post">
                    <div class="next gt-c-content-color-first">
                        下一篇：<a href="/2021/08/07/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" 
                            class="post-title gt-a-link">C++核心编程</a>
                    </div>
                </div>
            
        </div>
    
    
	
	<div class="post-toc" id="post-toc">
	    <div class="toc-label">
		    <div>目录</div>
			<a href="javascript:;" id="post-toc-close">
			    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" height="16" width="16">
				<path d="M193.94 256L296.5 153.44l21.15-21.15c3.12-3.12 3.12-8.19 0-11.31l-22.63-22.63c-3.12-3.12-8.19-3.12-11.31 0L160 222.06 36.29 98.34c-3.12-3.12-8.19-3.12-11.31 0L2.34 120.97c-3.12 3.12-3.12 8.19 0 11.31L126.06 256 2.34 379.71c-3.12 3.12-3.12 8.19 0 11.31l22.63 22.63c3.12 3.12 8.19 3.12 11.31 0L160 289.94 262.56 392.5l21.15 21.15c3.12 3.12 8.19 3.12 11.31 0l22.63-22.63c3.12-3.12 3.12-8.19 0-11.31L193.94 256z" fill="currentColor"></path>
				</svg>
			</a>
		</div>
		    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A8%A1%E6%9D%BF"><span class="toc-text">1 模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1 模板的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">1.2 函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="toc-text">1.2.1 函数模板语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">1.2.2 函数模板注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B"><span class="toc-text">1.2.3 函数模板案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.2.4 普通函数与函数模板的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">1.2.5 普通函数与函数模板的调用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-6-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">1.2.6 模板的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">1.3 类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="toc-text">1.3.1 类模板语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8C%BA%E5%88%AB"><span class="toc-text">1.3.2 类模板与函数模板区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-text">1.3.3 类模板中成员函数创建时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">1.3.4 类模板对象做函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-5-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">1.3.5 类模板与继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-6-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3.6 类模板成员函数类外实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-7-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%88%86%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="toc-text">1.3.7 类模板分文件编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-8-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83"><span class="toc-text">1.3.8 类模板与友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-9-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%A1%88%E4%BE%8B"><span class="toc-text">1.3.9 类模板案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-STL%E5%88%9D%E8%AF%86"><span class="toc-text">2 STL初识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-STL%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-text">2.1 STL的诞生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">2.2 STL基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">2.3 STL六大组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-STL%E4%B8%AD%E5%AE%B9%E5%99%A8%E3%80%81%E7%AE%97%E6%B3%95%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">2.4  STL中容器、算法、迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E8%AF%86"><span class="toc-text">2.5 容器算法迭代器初识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-vector%E5%AD%98%E6%94%BE%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.5.1 vector存放内置数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-Vector%E5%AD%98%E6%94%BE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.5.2 Vector存放自定义数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-Vector%E5%AE%B9%E5%99%A8%E5%B5%8C%E5%A5%97%E5%AE%B9%E5%99%A8"><span class="toc-text">2.5.3 Vector容器嵌套容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-STL-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="toc-text">3 STL- 常用容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-string%E5%AE%B9%E5%99%A8"><span class="toc-text">3.1 string容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-string%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1.1 string基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-string%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">3.1.2 string构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-string%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-text">3.1.3 string赋值操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-text">3.1.4 string字符串拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-string%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="toc-text">3.1.5 string查找和替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-6-string%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-text">3.1.6 string字符串比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-7-string%E5%AD%97%E7%AC%A6%E5%AD%98%E5%8F%96"><span class="toc-text">3.1.7 string字符存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-8-string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">3.1.8 string插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-9-string%E5%AD%90%E4%B8%B2"><span class="toc-text">3.1.9 string子串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-vector%E5%AE%B9%E5%99%A8"><span class="toc-text">3.2 vector容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-vector%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.2.1 vector基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">3.2.2 vector构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-vector%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-text">3.2.3 vector赋值操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-vector%E5%AE%B9%E9%87%8F%E5%92%8C%E5%A4%A7%E5%B0%8F"><span class="toc-text">3.2.4  vector容量和大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">3.2.5 vector插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-text">3.2.6 vector数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-7-vector%E4%BA%92%E6%8D%A2%E5%AE%B9%E5%99%A8"><span class="toc-text">3.2.7 vector互换容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-8-vector%E9%A2%84%E7%95%99%E7%A9%BA%E9%97%B4"><span class="toc-text">3.2.8 vector预留空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-deque%E5%AE%B9%E5%99%A8"><span class="toc-text">3.3 deque容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-deque%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.3.1 deque容器基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">3.3.2 deque构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-text">3.3.3 deque赋值操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">3.3.4 deque大小操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-deque-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">3.3.5 deque 插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-6-deque-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-text">3.3.6 deque 数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-7-deque-%E6%8E%92%E5%BA%8F"><span class="toc-text">3.3.7  deque 排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%A1%88%E4%BE%8B-%E8%AF%84%E5%A7%94%E6%89%93%E5%88%86"><span class="toc-text">3.4 案例-评委打分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E6%A1%88%E4%BE%8B%E6%8F%8F%E8%BF%B0"><span class="toc-text">3.4.1 案例描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">3.4.2 实现步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-stack%E5%AE%B9%E5%99%A8"><span class="toc-text">3.5 stack容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-stack-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.5.1 stack 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-stack-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.5.2 stack 常用接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-queue-%E5%AE%B9%E5%99%A8"><span class="toc-text">3.6 queue 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-queue-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.6.1 queue 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-queue-%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.6.2 queue 常用接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-list%E5%AE%B9%E5%99%A8"><span class="toc-text">3.7 list容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-1-list%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.7.1 list基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-2-list%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">3.7.2  list构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-3-list-%E8%B5%8B%E5%80%BC%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-text">3.7.3 list 赋值和交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-4-list-%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">3.7.4 list 大小操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-5-list-%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">3.7.5 list 插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-6-list-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="toc-text">3.7.6 list 数据存取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-7-list-%E5%8F%8D%E8%BD%AC%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-text">3.7.7 list 反转和排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-8-%E6%8E%92%E5%BA%8F%E6%A1%88%E4%BE%8B"><span class="toc-text">3.7.8 排序案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-set-multiset-%E5%AE%B9%E5%99%A8"><span class="toc-text">3.8 set&#x2F; multiset 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-1-set%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.8.1 set基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-2-set%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-text">3.8.2 set构造和赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-3-set%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-text">3.8.3 set大小和交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-4-set%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">3.8.4 set插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-5-set%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1"><span class="toc-text">3.8.5 set查找和统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-6-set%E5%92%8Cmultiset%E5%8C%BA%E5%88%AB"><span class="toc-text">3.8.6 set和multiset区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-7-pair%E5%AF%B9%E7%BB%84%E5%88%9B%E5%BB%BA"><span class="toc-text">3.8.7 pair对组创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-8-set%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F"><span class="toc-text">3.8.8 set容器排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-map-multimap%E5%AE%B9%E5%99%A8"><span class="toc-text">3.9 map&#x2F; multimap容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-1-map%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.9.1 map基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-2-map%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC"><span class="toc-text">3.9.2  map构造和赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-3-map%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BA%A4%E6%8D%A2"><span class="toc-text">3.9.3 map大小和交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-4-map%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">3.9.4 map插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-5-map%E6%9F%A5%E6%89%BE%E5%92%8C%E7%BB%9F%E8%AE%A1"><span class="toc-text">3.9.5 map查找和统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-6-map%E5%AE%B9%E5%99%A8%E6%8E%92%E5%BA%8F"><span class="toc-text">3.9.6 map容器排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E6%A1%88%E4%BE%8B-%E5%91%98%E5%B7%A5%E5%88%86%E7%BB%84"><span class="toc-text">3.10 案例-员工分组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-1-%E6%A1%88%E4%BE%8B%E6%8F%8F%E8%BF%B0"><span class="toc-text">3.10.1 案例描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-2-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">3.10.2 实现步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-STL-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">4 STL- 函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.1 函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5"><span class="toc-text">4.1.1 函数对象概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8"><span class="toc-text">4.1.2  函数对象使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%B0%93%E8%AF%8D"><span class="toc-text">4.2  谓词</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E8%B0%93%E8%AF%8D%E6%A6%82%E5%BF%B5"><span class="toc-text">4.2.1 谓词概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E4%B8%80%E5%85%83%E8%B0%93%E8%AF%8D"><span class="toc-text">4.2.2 一元谓词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D"><span class="toc-text">4.2.3 二元谓词</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.3 内建函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E6%84%8F%E4%B9%89"><span class="toc-text">4.3.1 内建函数对象意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E7%AE%97%E6%9C%AF%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">4.3.2 算术仿函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E5%85%B3%E7%B3%BB%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">4.3.3 关系仿函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E9%80%BB%E8%BE%91%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-text">4.3.4 逻辑仿函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-STL-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-text">5 STL- 常用算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-text">5.1 常用遍历算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-for-each"><span class="toc-text">5.1.1 for_each</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-transform"><span class="toc-text">5.1.2 transform</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-text">5.2 常用查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-find"><span class="toc-text">5.2.1 find</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-find-if"><span class="toc-text">5.2.2 find_if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-adjacent-find"><span class="toc-text">5.2.3 adjacent_find</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-binary-search"><span class="toc-text">5.2.4 binary_search</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-count"><span class="toc-text">5.2.5 count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-6-count-if"><span class="toc-text">5.2.6 count_if</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">5.3 常用排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-sort"><span class="toc-text">5.3.1 sort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-random-shuffle"><span class="toc-text">5.3.2 random_shuffle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-merge"><span class="toc-text">5.3.3 merge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-reverse"><span class="toc-text">5.3.4 reverse</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">5.4 常用拷贝和替换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-copy"><span class="toc-text">5.4.1 copy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-replace"><span class="toc-text">5.4.2 replace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-replace-if"><span class="toc-text">5.4.3 replace_if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-4-swap"><span class="toc-text">5.4.4 swap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="toc-text">5.5 常用算术生成算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-accumulate"><span class="toc-text">5.5.1 accumulate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-fill"><span class="toc-text">5.5.2 fill</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95"><span class="toc-text">5.6 常用集合算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-1-set-intersection"><span class="toc-text">5.6.1 set_intersection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-2-set-union"><span class="toc-text">5.6.2 set_union</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-3-set-difference"><span class="toc-text">5.6.3  set_difference</span></a></li></ol></li></ol></li></ol>
	</div>
</div>
<script>
    document.addEventListener("DOMContentLoaded",function(){
	    document.getElementById("toc-btn").onclick=function(){
		    document.getElementById("post-toc").classList.add("active")
		},
		document.getElementById("post-toc-close").onclick=function(){
		    document.getElementById("post-toc").classList.remove("active")
		},
		Array.from(document.getElementsByClassName("toc-link")).forEach(function(t){
		    t.addEventListener("click",function(t){
			    document.getElementById("post-toc").classList.remove("active")
			})
		})
	})
</script>
                <div class="site-footer gt-c-content-color-first">
    <div class="footer-main">
        <!-- 建议保留版权信息或者添加主题信息到友链，感谢您的理解 -->
        <!-- 文件位置：layout/_includes/footer.ejs -->
        <span style="text-align: right; float: right;">Theme <a 
            href="https://github.com/renbaoshuo/hexo-theme-pure" target="_blank">Pure</a> | Powered by <a 
            href="https://hexo.io" target="_blank">Hexo</a></span>
        <span style="text-align: left;">因为菜，所以更要学习
</span>
    </div>
</div>

            </div>
			<div class="fab">
			    
			    <a aria-label="文章目录" class="fab-btn" id="toc-btn" href="javascript:;" title="文章目录">
                    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" data-icon="list-ul" class="svg-inline--fa fa-list-ul fa-w-16" role="img" viewBox="0 0 512 512" height="20" width="20">
                        <path fill="currentColor" d="M48 48a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm0 160a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm0 160a48 48 0 1 0 48 48 48 48 0 0 0-48-48zm448 16H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z"></path>
                    </svg>
                </a>
				
			    <a aria_label="返回顶部" class="fab-btn" href="#" title="返回顶部">
				    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" role="img" viewBox="0 0 320 512" height="20" width="20">
					    <path fill="currentColor" d="M168.5 164.2l148 146.8c4.7 4.7 4.7 12.3 0 17l-19.8 19.8c-4.7 4.7-12.3 4.7-17 0L160 229.3 40.3 347.8c-4.7 4.7-12.3 4.7-17 0L3.5 328c-4.7-4.7-4.7-12.3 0-17l148-146.8c4.7-4.7 12.3-4.7 17 0z">
					    </path>
					</svg>
			    </a>
            </div>
    </body>
</html>